#ifndef _sf_bool_h
#define _sf_bool_h

#ifndef __cplusplus

#if defined(__STDC__) && (__STDC_VERSION__ >= 199901L)

#include <stdbool.h>       /* define bool, true, false */

#else

typedef enum {false, true} sf_Bool;
#define bool sf_Bool

#endif /* stdbool */

#endif /* c++ */

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_aastretch_h
#define _sf_aastretch_h




void sf_aastretch_init (bool box /* if box instead of triangle */,
			int n1   /* trace length */, 
			float o1 /* trace origin */, 
			float d1 /* trace sampling */, 
			int n2   /* number of data samples */);
/*< initialization >*/


void sf_aastretch_define (const float *coord /* data coordinates [nd] */, 
			  const float *delt  /* antialiasing length [nd] */, 
			  const float *amp   /* amplitude [nd] */);
/*< Set up interpolation >*/


void sf_aastretch_lop (bool adj    /* adjoint flag */,
		    bool add    /* addition flag */,
		    int n1, int n2, /* sizes */
		    float *ord  /* data [nd] */, 
		    float *modl /* model [nt] */);
/*< apply interpolation >*/


void sf_aastretch_close (void);
/*< free allocated storage >*/

#endif
#ifndef KISS_FFT_H
#define KISS_FFT_H

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
/* #include <malloc.h> */

#ifdef __cplusplus
extern "C" {
#endif

/*
 ATTENTION!
 If you would like a :
 -- a utility that will handle the caching of fft objects
 -- real-only (no imaginary time component ) FFT
 -- a multi-dimensional FFT
 -- a command-line utility to perform ffts
 -- a command-line utility to perform fast-convolution filtering

 Then see kfc.h kiss_fftr.h kiss_fftnd.h fftutil.c kiss_fastfir.c
  in the tools/ directory.
*/

#ifdef USE_SIMD
# include <xmmintrin.h>
# define kiss_fft_scalar __m128
#define KISS_FFT_MALLOC(nbytes) _mm_malloc(nbytes,16)
#define KISS_FFT_FREE _mm_free
#else	
#define KISS_FFT_MALLOC malloc
#define KISS_FFT_FREE free
#endif	


#ifdef FIXED_POINT
#include <sys/types.h>	
# if (FIXED_POINT == 32)
#  define kiss_fft_scalar int32_t
# else	
#  define kiss_fft_scalar int16_t
# endif
#else
# ifndef kiss_fft_scalar
/*  default is float */
#   define kiss_fft_scalar float
# endif
#endif

typedef struct {
    kiss_fft_scalar r;
    kiss_fft_scalar i;
}kiss_fft_cpx;

typedef struct kiss_fft_state* kiss_fft_cfg;

/* 
 *  kiss_fft_alloc
 *  
 *  Initialize a FFT (or IFFT) algorithm's cfg/state buffer.
 *
 *  typical usage:      kiss_fft_cfg mycfg=kiss_fft_alloc(1024,0,NULL,NULL);
 *
 *  The return value from fft_alloc is a cfg buffer used internally
 *  by the fft routine or NULL.
 *
 *  If lenmem is NULL, then kiss_fft_alloc will allocate a cfg buffer using malloc.
 *  The returned value should be free()d when done to avoid memory leaks.
 *  
 *  The state can be placed in a user supplied buffer 'mem':
 *  If lenmem is not NULL and mem is not NULL and *lenmem is large enough,
 *      then the function places the cfg in mem and the size used in *lenmem
 *      and returns mem.
 *  
 *  If lenmem is not NULL and ( mem is NULL or *lenmem is not large enough),
 *      then the function returns NULL and places the minimum cfg 
 *      buffer size in *lenmem.
 * */

kiss_fft_cfg kiss_fft_alloc(int nfft,int inverse_fft,void * mem,size_t * lenmem); 

/*
 * kiss_fft(cfg,in_out_buf)
 *
 * Perform an FFT on a complex input buffer.
 * for a forward FFT,
 * fin should be  f[0] , f[1] , ... ,f[nfft-1]
 * fout will be   F[0] , F[1] , ... ,F[nfft-1]
 * Note that each element is complex and can be accessed like
    f[k].r and f[k].i
 * */
void kiss_fft(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout);

/*
 A more generic version of the above function. It reads its input from every Nth sample.
 * */
void kiss_fft_stride(kiss_fft_cfg cfg,const kiss_fft_cpx *fin,kiss_fft_cpx *fout,int fin_stride);

/* If kiss_fft_alloc allocated a buffer, it is one contiguous 
   buffer and can be simply free()d when no longer needed*/
#define kiss_fft_free free

/*
 Cleans up some memory that gets managed internally. Not necessary to call, but it might clean up 
 your compiler output to call this before you exit.
*/
void kiss_fft_cleanup(void);
	

/*
 * Returns the smallest integer k, such that k>=n and k has only "fast" factors (2,3,5)
 */
int kiss_fft_next_fast_size(int n);

/* for real ffts, we need an even size */
#define kiss_fftr_next_fast_size_real(n) \
        (kiss_fft_next_fast_size( ((n)+1)>>1)<<1)

#ifdef __cplusplus
} 
#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_c99_h
#define _sf_c99_h


#include <math.h>


#if !defined (__cplusplus) && !defined(NO_COMPLEX) && defined(__STDC__) && ((__STDC_VERSION__ >= 199901L) || defined(__ICC))


#define SF_HAS_COMPLEX_H


/* The following from C99 - must define for C90 */
#include <complex.h>
#undef I
#ifdef sun
#define I (1.0fi)
#else
#define I _Complex_I
#endif


typedef float complex sf_complex;
typedef double complex sf_double_complex;


#else


typedef kiss_fft_cpx sf_complex;
typedef struct {
    double r, i;
} sf_double_complex;


#endif


#ifdef SF_HAS_COMPLEX_H


float complex sf_cmplx(float re, float im);
/*< complex number >*/


double complex sf_dcmplx(double re, double im);
/*< complex number >*/


#else


kiss_fft_cpx sf_cmplx(float re, float im);
/*< complex number >*/


sf_double_complex sf_dcmplx(double re, double im);
/*< complex number >*/


#endif


#if !defined(__cplusplus) && !defined(SF_HAS_COMPLEX_H)


#if !defined(hpux) && !defined(__hpux)


float copysignf(float x, float y);
/*< float copysign >*/


#endif


float sqrtf(float x);
/*< float sqrt >*/


float logf(float x);
/*< float log >*/


float log10f(float x);
/*< float log10 >*/


float expf(float x);
/*< float exp >*/


float erff(float x);
/*< float erf >*/


float erfcf(float x);
/*< float erfc >*/


#if !defined(hpux) && !defined(__hpux)


float fabsf(float x);
/*< float fabs >*/


#endif


float fmaxf(float x, float y);
/*< float fmax >*/


float fminf(float x, float y);
/*< float fmin >*/


float floorf(float x);
/*< float floor >*/


float ceilf(float x);
/*< float ceil >*/


float roundf(float x);
/*< round to nearest integer >*/


float fmodf(float x, float y);
/*< float fmod >*/


float cosf(float x);
/*< float cos >*/


float sinf(float x);
/*< float sin >*/


float tanf(float x);
/*< float tan >*/


float acosf(float x);
/*< float acos >*/


float asinf(float x);
/*< float asin >*/


float atanf(float x);
/*< float atan >*/


float atan2f(float x, float y);
/*< float atan2 >*/


float log2f(float x);
/*< float log2 >*/


float coshf(float x);
/*< float cosh >*/


float sinhf(float x);
/*< float sinh >*/


float tanhf(float x);
/*< float tanh >*/


float acoshf(float x);
/*< float acosh >*/


float asinhf(float x);
/*< float asinh >*/


float atanhf(float x);
/*< float atanh >*/


float powf(float x, float y);
/*< float pow >*/


float hypotf(float x, float y);
/*< float hypot >*/


long lrint(double num);
/*< round to integer >*/


long long llround(double num);
/*< round to integer >*/


#if defined(hpux) || defined(__hpux)


long long
strtoll(const char *ptr, const char **endptr, int base);
/*< strtoll replacement >*/


unsigned long long
strtoull(const char *ptr, const char **endptr, int base);
/*< strtoull replacement >*/


#endif


#ifdef sun
extern int finite(double);
#define isfinite(x) finite(x)
#endif


#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_adjnull_h
#define _sf_adjnull_h




void sf_adjnull (bool adj /* adjoint flag */, 
		 bool add /* addition flag */, 
		 int nx   /* size of x */, 
		 int ny   /* size of y */, 
		 float* x, 
		 float* y);
/*< Zeros out the output (unless add is true). 
  Useful first step for any linear operator. >*/


void sf_cadjnull (bool adj /* adjoint flag */, 
		  bool add /* addition flag */, 
		  int nx   /* size of x */, 
		  int ny   /* size of y */, 
		  sf_complex* x, 
		  sf_complex* y);
/*< adjnull version for complex data. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_alloc_h
#define _sf_alloc_h


#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>


#include <stdlib.h>




/*------------------------------------------------------------*/
/*@out@*/ void *sf_alloc (size_t n    /* number of elements */, 
			  size_t size /* size of one element */);
/*< output-checking allocation >*/


/*------------------------------------------------------------*/
void *sf_realloc (void* ptr   /* previous data */, 
		  size_t n    /* number of elements */, 
		  size_t size /* size of one element */);
/*< output-checing reallocation >*/


/*------------------------------------------------------------*/
/*@out@*/ char *sf_charalloc (size_t n /* number of elements */);
/*< char allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ unsigned char *sf_ucharalloc (size_t n /* number of elements */);
/*< unsigned char allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ short *sf_shortalloc (size_t n /* number of elements */);
/*< short allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ int *sf_intalloc (size_t n /* number of elements */);
/*< int allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ off_t *sf_largeintalloc (size_t n /* number of elements */);
/*< sf_largeint allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ float *sf_floatalloc (size_t n /* number of elements */);
/*< float allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ sf_complex *sf_complexalloc (size_t n /* number of elements */);
/*< complex allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ sf_complex **sf_complexalloc2 (size_t n1 /* fast dimension */, 
					 size_t n2 /* slow dimension */);
/*< complex 2-D allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ sf_complex ***sf_complexalloc3 (size_t n1 /* fast dimension */, 
					  size_t n2 /* slower dimension */, 
					  size_t n3 /* slowest dimension */);
/*< complex 3-D allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ sf_complex ****sf_complexalloc4 (size_t n1 /* fast dimension */, 
					   size_t n2 /* slower dimension */, 
					   size_t n3 /* slower dimension */, 
					   size_t n4 /* slowest dimension */);
/*< complex 4-D allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ sf_complex *****sf_complexalloc5 (size_t n1 /* fast dimension */, 
					    size_t n2 /* slower dimension */, 
					    size_t n3 /* slower dimension */, 
					    size_t n4 /* slower dimension */,
					    size_t n5 /* slowest dimension */);
/*< complex 5-D allocation >*/


/*------------------------------------------------------------*/
/*@out@*/ bool *sf_boolalloc (size_t n /* number of elements */);
/*< bool allocation >*/


/*@out@*/ bool **sf_boolalloc2 (size_t n1 /* fast dimension */, 
				size_t n2 /* slow dimension */);
/*< bool 2-D allocation, out[0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ bool ***sf_boolalloc3 (size_t n1 /* fast dimension */, 
				  size_t n2 /* slower dimension */, 
				  size_t n3 /* slowest dimension */);
/*< bool 3-D allocation, out[0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ float **sf_floatalloc2 (size_t n1 /* fast dimension */, 
				  size_t n2 /* slow dimension */);
/*< float 2-D allocation, out[0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ float ***sf_floatalloc3 (size_t n1 /* fast dimension */, 
				   size_t n2 /* slower dimension */, 
				   size_t n3 /* slowest dimension */);
/*< float 3-D allocation, out[0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ float ****sf_floatalloc4 (size_t n1 /* fast dimension */, 
				    size_t n2 /* slower dimension */, 
				    size_t n3 /* slower dimension */, 
				    size_t n4 /* slowest dimension */);
/*< float 4-D allocation, out[0][0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ float *****sf_floatalloc5 (size_t n1 /* fast dimension */, 
				     size_t n2 /* slower dimension */, 
				     size_t n3 /* slower dimension */, 
				     size_t n4 /* slower dimension */,
				     size_t n5 /* slowest dimension */);
/*< float 5-D allocation, out[0][0][0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ float ******sf_floatalloc6 (size_t n1 /* fast dimension */, 
				      size_t n2 /* slower dimension */, 
				      size_t n3 /* slower dimension */, 
				      size_t n4 /* slower dimension */,
				      size_t n5 /* slower dimension */,
				      size_t n6 /* slowest dimension */);
/*< float 6-D allocation, out[0][0][0][0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ int **sf_intalloc2 (size_t n1 /* fast dimension */, 
			      size_t n2 /* slow dimension */);
/*< float 2-D allocation, out[0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ int ***sf_intalloc3 (size_t n1 /* fast dimension */, 
			       size_t n2 /* slower dimension */, 
			       size_t n3 /* slowest dimension */);
/*< int 3-D allocation, out[0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ int ****sf_intalloc4 (size_t n1 /* fast dimension */, 
			       size_t n2 /* slower dimension */, 
			       size_t n3 /* slower dimension */,
			       size_t n4 /* slowest dimension */ );
/*< int 4-D allocation, out[0][0][0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ char **sf_charalloc2 (size_t n1 /* fast dimension */, 
				size_t n2 /* slow dimension */);
/*< char 2-D allocation, out[0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ unsigned char **sf_ucharalloc2 (size_t n1 /* fast dimension */, 
					  size_t n2 /* slow dimension */);
/*< unsigned char 2-D allocation, out[0] points to a contiguous array >*/


/*------------------------------------------------------------*/
/*@out@*/ unsigned char ***sf_ucharalloc3 (size_t n1 /* fast dimension */, 
					   size_t n2 /* slower dimension */, 
					   size_t n3 /* slowest dimension */);
/*< unsigned char 3-D allocation, out[0][0] points to a contiguous array >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_file_h
#define _sf_file_h


#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>


#include <stdio.h>




#define SF_MAX_DIM 9


typedef struct sf_File *sf_file;


typedef enum {SF_UCHAR, SF_CHAR, SF_INT, SF_FLOAT, SF_COMPLEX, SF_SHORT, SF_DOUBLE, SF_LONG} sf_datatype;
typedef enum {SF_ASCII, SF_XDR, SF_NATIVE} sf_dataform;


void sf_file_error(bool err);
/*< set error on opening files >*/


sf_file sf_input (/*@null@*/ const char* tag);
/*< Create an input file structure >*/


sf_file sf_output (/*@null@*/ const char* tag);
/*< Create an output file structure.
  ---
  Should do output after the first call to sf_input. >*/


sf_datatype sf_gettype (sf_file file);
/*< return file type >*/


sf_dataform sf_getform (sf_file file);
/*< return file form >*/


size_t sf_esize(sf_file file);
/*< return element size >*/


void sf_settype (sf_file file, sf_datatype type);
/*< set file type >*/


void sf_setpars (sf_file file);
/*< change parameters to those from the command line >*/


void sf_expandpars (sf_file file);
/*< add parameters from the command line >*/


size_t sf_bufsiz(sf_file file);
/*< return buffer size for efficient I/O >*/


void sf_setform (sf_file file, sf_dataform form);
/*< set file form >*/


void sf_setformat (sf_file file, const char* format);
/*< Set file format.
  ---
  format has a form "form_type", i.e. native_float, ascii_int, etc.
  >*/


void sf_fileclose (sf_file file);
/*< close a file and free allocated space >*/


void sf_fileclosedelete (sf_file file);
/*< close a file and then delete the file from disk >*/


bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par);
/*< read an int parameter from file >*/


bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n);
/*< read an int array of size n parameter from file >*/


bool sf_histlargeint (sf_file file, const char* key,/*@out@*/ off_t* par);
/*< read a sf_largeint parameter from file >*/


bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par);
/*< read a float parameter from file >*/


bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par);
/*< read a float parameter from file >*/


bool sf_histfloats (sf_file file, const char* key,
		    /*@out@*/ float* par,size_t n);
/*< read a float array of size n parameter from file >*/


bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par);
/*< read a bool parameter from file >*/


bool sf_histbools (sf_file file, const char* key,
		   /*@out@*/ bool* par, size_t n);
/*< read a bool array of size n parameter from file >*/


char* sf_histstring (sf_file file, const char* key);
/*< read a string parameter from file (returns NULL on failure) >*/


void sf_fileflush (sf_file file, sf_file src);
/*< outputs parameter to a file (initially from source src)
  ---
  Prepares file for writing binary data >*/


void sf_readwrite(sf_file file, bool flag);
/*< set the readwrite flag >*/


void sf_fflush(sf_file file);
/*< flush file stream >*/


void sf_putint (sf_file file, const char* key, int par);
/*< put an int parameter to a file >*/


void sf_putints (sf_file file, const char* key, const int* par, size_t n);
/*< put an int array of size n parameter to a file >*/


void sf_putlargeint (sf_file file, const char* key, off_t par);
/*< put a sf_largeint parameter to a file >*/


void sf_putfloat (sf_file file, const char* key,float par);
/*< put a float parameter to a file >*/


void sf_putfloats (sf_file file, const char* key, const float* par, size_t n);
/*< put a float array of size n parameter to a file >*/


void sf_putstring (sf_file file, const char* key,const char* par);
/*< put a string parameter to a file >*/


void sf_putline (sf_file file, const char* line);
/*< put a string line to a file >*/


void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
		    int line /* numbers in line */,
		    int strip /* strip last characters */);
/*< Set format for ascii output >*/


void sf_complexwrite (sf_complex* arr, size_t size, sf_file file);
/*< write a complex array arr[size] to file >*/


void sf_complexread (/*@out@*/ sf_complex* arr, size_t size, sf_file file);
/*< read a complex array arr[size] from file >*/


void sf_charwrite (char* arr, size_t size, sf_file file);
/*< write a char array arr[size] to file >*/


void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file);
/*< write an unsigned char array arr[size] to file >*/


void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file);
/*< read a char array arr[size] from file >*/


int sf_try_charread(const char* test, sf_file file);
/*< check if you can read test word >*/


int sf_try_charread2 (/*@out@*/ char* arr, size_t size, sf_file file);
/*< try to read size bytes.  return number bytes read >*/


void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file);
/*< read a uchar array arr[size] from file >*/


void sf_intwrite (int* arr, size_t size, sf_file file);
/*< write an int array arr[size] to file >*/


void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file);
/*< read an int array arr[size] from file >*/


void sf_shortread (/*@out@*/ short* arr, size_t size, sf_file file);
/*< read a short array arr[size] from file >*/


void sf_longread (/*@out@*/ off_t* arr, size_t size, sf_file file);
/*< read a long array arr[size] from file >*/


void sf_shortwrite (short* arr, size_t size, sf_file file);
/*< write a short array arr[size] to file >*/


void sf_floatwrite (float* arr, size_t size, sf_file file);
/*< write a float array arr[size] to file >*/


void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file);
/*< read a float array arr[size] from file >*/


off_t sf_bytes (sf_file file);
/*< Count the file data size (in bytes) >*/


off_t sf_tell (sf_file file);
/*< Find position in file >*/


FILE *sf_tempfile(char** dataname, const char* mode);
/*< Create a temporary file with a unique name >*/


void sf_seek (sf_file file, off_t offset, int whence);
/*< Seek to a position in file. Follows fseek convention. >*/


FILE* sf_filestream (sf_file file);
/*< Returns file descriptor to a stream >*/


void sf_unpipe (sf_file file, off_t size);
/*< Redirect a pipe input to a direct access file >*/


void sf_close(void);
/*< Remove temporary files >*/


sf_file sf_tmpfile(char *format);
/*< Create an temporary (rw mode) file structure. Lives within the program >*/


void sf_filefresh(sf_file file);
/*< used for temporary file only to recover the dataname >*/


void sf_filecopy(sf_file file, sf_file src, sf_datatype type);
/*< copy the content in src->stream to file->stream >*/


void sf_tmpfileclose (sf_file file);
/*< close a file and free allocated space >*/


bool sf_endian (void);
/*< Endianness test, returns true for little-endian machines >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_axa_h
#define _sf_axa_h




typedef struct {
    int n;
    float o,d;
} sf_axa;


typedef struct sf_Axis *sf_axis;


/*------------------------------------------------------------*/
sf_axis sf_maxa(int n   /* length */, 
		float o /* origin */, 
		float d /* sampling */);
/*< make a simple axis >*/


void sf_maxa_free (sf_axis tofree);
/*< free allocated storage >*/


sf_axis sf_iaxa(sf_file FF, int i);
/*< read axis i >*/


void sf_oaxa(sf_file FF, const sf_axis AA, int i);
/*< write axis i >*/


void sf_raxa(const sf_axis AA);
/*< report information on axis AA >*/


int sf_n(const sf_axis AA);
/*< access axis length >*/


float sf_o(const sf_axis AA);
/*< access axis origin >*/


float sf_d(const sf_axis AA);
/*< access axis sampling >*/


sf_axa sf_nod(const sf_axis AA);
/*< access length, origin, and sampling >*/


void sf_setn(sf_axis AA, int n);
/*< change axis length >*/


void sf_seto(sf_axis AA, float o);
/*< change axis origin >*/


void sf_setd(sf_axis AA, float d);
/*< change axis sampling >*/


void sf_setlabel(sf_axis AA, const char* label);
/*< change axis label >*/


void sf_setunit(sf_axis AA, const char* unit);
/*< change axis unit >*/


void sf_copyaxis(     sf_axis AA,
	 	const sf_axis BB);
/*< copy axis >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_banded_h
#define _sf_banded_h


typedef struct sf_Bands *sf_bands;
/* abstract data type */


sf_bands sf_banded_init (int n    /* matrix size */, 
			 int band /* band size */);
/*< initialize >*/


void sf_banded_define (sf_bands slv, 
		       float* diag  /* diagonal [n] */, 
		       float** offd /* off-diagonal [band][n] */);
/*< define the matrix >*/


void sf_banded_const_define (sf_bands slv, 
			     float diag        /* diagonal */, 
			     const float* offd /* off-diagonal [band] */);
/*< define matrix with constant diagonal coefficients >*/


void sf_banded_const_define_eps (sf_bands slv, 
				 float diag        /* diagonal */, 
				 const float* offd /* off-diagonal [band] */, 
				 int nb            /* size of the boundary */,
				 float eps         /* regularization parameter */);
/*< define matrix with constant diagonal coefficients 
  and regularized b.c. >*/


void sf_banded_const_define_reflect (sf_bands slv, 
				     float diag        /* diagonal */, 
				     const float* offd /* off-diagonal [band] */);
/*< define matrix with constant diagonal coefficients  
  and reflecting b.c. >*/


void sf_banded_solve (const sf_bands slv, float* b);
/*< invert (in place) >*/


void sf_banded_close (sf_bands slv);
/*< free allocated storage >*/

#endif
/* Operator types for linear solvers. */
/*
  Copyright (C) 2004 University of Texas at Austin
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _sf__solver_h
#define _sf__solver_h


typedef void (*sf_operator)(bool,bool,int,int,float*,float*);
typedef void (*sf_solverstep)(bool,int,int,float*,
			   const float*,float*,const float*);
typedef void (*sf_weight)(int,const float*,float*);
/*^*/

typedef void (*sf_coperator)(bool,bool,int,int,sf_complex*,sf_complex*);
typedef void (*sf_csolverstep)(bool,int,int,sf_complex*,
			       const sf_complex*,sf_complex*,
			       const sf_complex*);
typedef void (*sf_cweight)(int,const sf_complex*,float*);
/*^*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_bigsolver_h
#define _sf_bigsolver_h






void sf_solver_prec (sf_operator oper   /* linear operator */, 
		     sf_solverstep solv /* stepping function */, 
		     sf_operator prec   /* preconditioning operator */, 
		     int nprec          /* size of p */, 
		     int nx             /* size of x */, 
		     int ny             /* size of dat */, 
		     float* x           /* estimated model */, 
		     const float* dat   /* data */, 
		     int niter          /* number of iterations */, 
		     double eps          /* regularization parameter */, 
		     ...                /* variable number of arguments */);
/*< Generic preconditioned linear solver.
 ---
 Solves
 oper{x} =~ dat
 eps p   =~ 0
 where x = prec{p}
 ---
 The last parameter in the call to this function should be "end".
 Example: 
 ---
 sf_solver_prec (oper_lop,sf_cgstep,prec_lop,
 np,nx,ny,x,y,100,1.0,"x0",x0,"end");
 ---
 Parameters in ...:
 ... 
 "wt":     float*:         weight      
 "wght":   sf_weight wght: weighting function
 "x0":     float*:         initial model
 "nloper": sf_operator:    nonlinear operator  
 "mwt":    float*:         model weight
 "verb":   bool:           verbosity flag
 "known":  bool*:          known model mask
 "nmem":   int:            iteration memory
 "nfreq":  int:            periodic restart
 "xmov":   float**:        model iteration
 "rmov":   float**:        residual iteration
 "err":    float*:         final error
 "res":    float*:         final residual
 "xp":     float*:         preconditioned model
 >*/


void sf_csolver_prec (sf_coperator oper   /* linear operator */, 
		      sf_csolverstep solv /* stepping function */, 
		      sf_coperator prec   /* preconditioning operator */, 
		      int nprec          /* size of p */, 
		      int nx             /* size of x */, 
		      int ny             /* size of dat */, 
		      sf_complex* x           /* estimated model */, 
		      const sf_complex* dat   /* data */, 
		      int niter          /* number of iterations */, 
		      double eps          /* regularization parameter */, 
		     ...                /* variable number of arguments */);
/*< Generic preconditioned linear solver.
 ---
 Solves
 oper{x} =~ dat
 eps p   =~ 0
 where x = prec{p}
 ---
 The last parameter in the call to this function should be "end".
 Example: 
 ---
 sf_csolver_prec (oper_lop,sf_cgstep,prec_lop,
 np,nx,ny,x,y,100,1.0,"x0",x0,"end");
 ---
 Parameters in ...:
 ... 
 "wt":     float*:         weight      
 "wght":   sf_cweight wght: weighting function
 "x0":     sf_complex*:         initial model
 "nloper": sf_coperator:   nonlinear operator  
 "mwt":    float*:         model weight
 "verb":   bool:           verbosity flag
 "known":  bool*:          known model mask
 "nmem":   int:            iteration memory
 "nfreq":  int:            periodic restart
 "xmov":   sf_complex**:        model iteration
 "rmov":   sf_complex**:        residual iteration
 "err":    sf_float*:         final error
 "res":    sf_complex*:         final residual
 "xp":     sf_complex*:         preconditioned model
 >*/


void sf_solver_reg (sf_operator oper   /* linear operator */, 
		    sf_solverstep solv /* stepping function */,
		    sf_operator reg    /* regularization operator */, 
		    int nreg           /* size of reg{x} */, 
		    int nx             /* size of x */, 
		    int ny             /* size of dat */, 
		    float* x           /* estimated model */, 
		    const float* dat   /* data */, 
		    int niter          /* number of iterations */, 
		    double eps          /* regularization parameter */, 
		    ...                /* variable number of arguments */);
/*< Generic regularized linear solver.
  ---
  Solves
  oper{x}    =~ dat
  eps reg{x} =~ 0
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_solver_reg (oper_lop,sf_cgstep,reg_lop,
  np,nx,ny,x,y,100,1.0,"x0",x0,"end");
  ---
  Parameters in ...:
  
  "wt":     float*:         weight      
  "wght":   sf_weight wght: weighting function
  "x0":     float*:         initial model
  "nloper": sf_operator:    nonlinear operator  
  "nlreg":  sf_operator:    nonlinear regularization operator
  "verb":   bool:           verbosity flag
  "known":  bool*:          known model mask
  "nmem":   int:            iteration memory
  "nfreq":  int:            periodic restart
  "xmov":   float**:        model iteration
  "rmov":   float**:        residual iteration
  "err":    float*:         final error
  "res":    float*:         final residual
  "resm":   float*:         final model residual
  >*/


void sf_csolver_reg (sf_coperator oper   /* linear operator */, 
		     sf_csolverstep solv /* stepping function */,
		     sf_coperator reg    /* regularization operator */, 
		     int nreg            /* size of reg{x} */, 
		     int nx              /* size of x */, 
		     int ny              /* size of dat */, 
		     sf_complex* x           /* estimated model */, 
		     const sf_complex* dat   /* data */, 
		     int niter          /* number of iterations */, 
		     double eps          /* regularization parameter */, 
		    ...                /* variable number of arguments */);
/*< Generic regularized linear solver.
  ---
  Solves
  oper{x}    =~ dat
  eps reg{x} =~ 0
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_solver_reg (oper_lop,sf_cgstep,reg_lop,
  np,nx,ny,x,y,100,1.0,"x0",x0,"end");
  ---
  Parameters in ...:
  
  "x0":     sf_complex*:         initial model
  "nloper": sf_operator:    nonlinear operator  
  "nlreg":  sf_operator:    nonlinear regularization operator
  "verb":   bool:           verbosity flag
  "known":  bool*:          known model mask
  "nmem":   int:            iteration memory
  "nfreq":  int:            periodic restart
  "xmov":   sf_complex**:        model iteration
  "rmov":   sf_complex**:        residual iteration
  "err":    float*:         final error
  "res":    sf_complex*:         final residual
  "resm":   sf_complex*:         final model residual
  >*/


void sf_solver (sf_operator oper   /* linear operator */, 
		sf_solverstep solv /* stepping function */, 
		int nx             /* size of x */, 
		int ny             /* size of dat */, 
		float* x           /* estimated model */, 
		const float* dat   /* data */, 
		int niter          /* number of iterations */, 
		...                /* variable number of arguments */);
/*< Generic linear solver.
  ---
  Solves
  oper{x}    =~ dat
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_solver (oper_lop,sf_cgstep,nx,ny,x,y,100,"x0",x0,"end");
  ---
  Parameters in ...:
  ---
  "wt":     float*:         weight      
  "wght":   sf_weight wght: weighting function
  "x0":     float*:         initial model
  "nloper": sf_operator:    nonlinear operator
  "mwt":    float*:         model weight
  "verb":   bool:           verbosity flag
  "known":  bool*:          known model mask
  "nmem":   int:            iteration memory
  "nfreq":  int:            periodic restart
  "xmov":   float**:        model iteration
  "rmov":   float**:        residual iteration
  "err":    float*:         final error
  "res":    float*:         final residual
  >*/


void sf_left_solver (sf_operator oper   /* linear operator */, 
		     sf_solverstep solv /* stepping function */, 
		     int nx             /* size of x and dat */, 
		     float* x           /* estimated model */, 
		     const float* dat   /* data */, 
		     int niter          /* number of iterations */, 
		     ...                /* variable number of arguments */);
/*< Generic linear solver for non-symmetric operators.
  ---
  Solves
  oper{x}    =~ dat
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_left_solver (oper_lop,sf_cdstep,nx,ny,x,y,100,"x0",x0,"end");
  ---
  Parameters in ...:
  ---
  "wt":     float*:         weight      
  "wght":   sf_weight wght: weighting function
  "x0":     float*:         initial model
  "nloper": sf_operator:    nonlinear operator
  "mwt":    float*:         model weight
  "verb":   bool:           verbosity flag
  "known":  bool*:          known model mask
  "nmem":   int:            iteration memory
  "nfreq":  int:            periodic restart
  "xmov":   float**:        model iteration
  "rmov":   float**:        residual iteration
  "err":    float*:         final error
  "res":    float*:         final residual
  >*/


void sf_csolver (sf_coperator oper        /* linear operator */, 
		 sf_csolverstep solv      /* stepping function */, 
		 int nx                   /* size of x */, 
		 int ny                   /* size of dat */, 
		 sf_complex* x            /* estimated model */, 
		 const sf_complex* dat    /* data */, 
		 int niter                /* number of iterations */, 
		 ...                      /* variable number of arguments */);
/*< Generic linear solver for complex data.
  ---
  Solves
  oper{x}    =~ dat
  ---
  The last parameter in the call to this function should be "end".
  Example: 
  ---
  sf_csolver (oper_lop,sf_cgstep,nx,ny,x,y,100,"x0",x0,"end");
  ---
  Parameters in ...:
  ---
  "wt":     float*:          weight      
  "wght":   sf_cweight wght: weighting function
  "x0":     sf_complex*:  initial model
  "nloper": sf_coperator:    nonlinear operator  
  "verb":   bool:            verbosity flag
  "known":  bool*:           known model mask
  "nmem":   int:             iteration memory
  "nfreq":  int:             periodic restart
  "xmov":   sf_complex**: model iteration
  "rmov":   sf_complex**: residual iteration
  "err":    float*:  final error
  "res":    sf_complex*:  final residual
  >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_blas_h
#define _sf_blas_h


#ifndef NO_BLAS


#ifdef __APPLE__
#define VIMAGE_H
/* #define __VECLIB__ */
#include <Accelerate/Accelerate.h>
#else
#ifdef HAVE_MKL
#include <mkl.h>
#else
#include <cblas.h>
#endif


#ifdef __sgi


double cblas_dsdot(int n, const float *x, int sx, const float *y, int sy);
/*< x'y float -> double >*/


#endif


#endif


#else


void cblas_saxpy(int n, float a, const float *x, int sx, float *y, int sy);
/*< y += a*x >*/


void cblas_sswap(int n, float *x, int sx, float* y, int sy);
/*< swap x and y >*/


float cblas_sdot(int n, const float *x, int sx, const float *y, int sy);
/*< x'y float -> complex >*/


double cblas_dsdot(int n, const float *x, int sx, const float *y, int sy);
/*< x'y float -> complex >*/


float cblas_snrm2 (int n, const float* x, int sx);
/*< sum x_i^2 >*/


float cblas_scnrm2 (int n, const void* x, int sx);
/*< sum |x_i|^2 >*/


void cblas_sscal(int n, float alpha, float *x, int sx);
/*< x = alpha*x >*/


void cblas_csscal(int n, float alpha, void *x, int sx);
/*< x = alpha*x >*/


void cblas_cdotc_sub(int n, 
		     const void *x, int sx,
		     const void *y, int sy, void *dot);
/*< complex hermitian dot product >*/


#endif

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_box_h
#define _sf_box_h




void sf_box_init (int nbox /* box length */, 
		  int ndat /* data length */, 
		  bool lin /* true for linear operator */);
/*< initialize >*/


void sf_box_close (void);
/*< free allocated storage >*/


void sf_boxsmooth (int o    /* start */, 
		   int d    /* increment */, 
		   float *x /* output */, 
		   float *y /* input */);
/*< adjoint smoothing >*/


void sf_boxsmooth2 (int o    /* start */, 
		    int d    /* increment */, 
		    float *x /* input */, 
		    float *y /* output */);
/*< smoothing >*/


void sf_box_lop(bool adj, bool add, int nx, int ny, float* x, float* y);
/*< smoothing as linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_butter_h
#define _sf_butter_h


/* Implementation is inspired by D. Hale and J.F. Claerbout, 1983, Butterworth
 * dip filters: Geophysics, 48, 1033-1038. */
    


typedef struct Sf_Butter *sf_butter;
/* abstract data type */


sf_butter sf_butter_init(bool low     /* low-pass (or high-pass) */, 
		   float cutoff /* cut off frequency */, 
		   int nn       /* number of poles */);
/*< initialize >*/


void sf_butter_close(sf_butter bw);
/*< Free allocated storage >*/


void sf_butter_apply (const sf_butter bw, int nx, float *x /* data [nx] */);
/*< filter the data (in place) >*/


void sf_reverse (int n1, float* trace);
/*< reverse a trace >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_causint_h
#define _sf_causint_h




void sf_causint_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_komplex_h
#define _sf_komplex_h




#ifndef SF_HAS_COMPLEX_H


#define crealf  sf_crealf
#define creal   sf_creal
#define cimagf  sf_cimagf
#define cimag   sf_cimag
#define conjf   sf_conjf
#define cabsf   sf_cabsf
#define cabs    sf_cabsd
#define cargf   sf_cargf
#define carg    sf_carg
#define ccosf   sf_ccosf
#define csinf   sf_csinf
#define ctanf   sf_ctanf
#define cacosf  sf_cacosf
#define casinf  sf_casinf
#define catanf  sf_catanf
#define ccoshf  sf_ccoshf
#define csinhf  sf_csinhf
#define ctanhf  sf_ctanhf
#define cacoshf sf_cacoshf
#define casinhf sf_casinhf
#define catanhf sf_catanhf
#define cexpf   sf_cexpf
#define clogf   sf_clogf
#define csqrtf  sf_csqrtf
#define cpowf   sf_cpowf


double sf_creal(sf_double_complex c);
/*< real part >*/


double sf_cimag(sf_double_complex c);
/*< imaginary part >*/


sf_double_complex sf_dcneg(sf_double_complex a);
/*< unary minus >*/


sf_double_complex sf_dcadd(sf_double_complex a, sf_double_complex b);
/*< complex addition >*/


sf_double_complex sf_dcsub(sf_double_complex a, sf_double_complex b);
/*< complex subtraction >*/


sf_double_complex sf_dcmul(sf_double_complex a, sf_double_complex b);
/*< complex multiplication >*/


kiss_fft_cpx sf_dccmul(sf_double_complex a, kiss_fft_cpx b);
/*< complex multiplication >*/


sf_double_complex sf_dcdmul(sf_double_complex a, kiss_fft_cpx b);
/*< complex multiplication >*/


sf_double_complex sf_dcrmul(sf_double_complex a, double b);
/*< complex by real multiplication >*/


sf_double_complex sf_dcdiv(sf_double_complex a, sf_double_complex b);
/*< complex division >*/


double sf_carg(sf_double_complex z);
/*< replacement for cargf >*/


double sf_cabsd(sf_double_complex z);
/*< replacement for cabs >*/


#endif


#if !defined(__cplusplus)


float sf_cabs(sf_complex c);
/*< complex absolute value >*/


#endif


float sf_crealf(kiss_fft_cpx c);
/*< real part >*/


float sf_cimagf(kiss_fft_cpx c);
/*< imaginary part >*/


void cprint (sf_complex c);
/*< print a complex number (for debugging purposes) >*/


kiss_fft_cpx sf_cadd(kiss_fft_cpx a, kiss_fft_cpx b);
/*< complex addition >*/


kiss_fft_cpx sf_csub(kiss_fft_cpx a, kiss_fft_cpx b);
/*< complex subtraction >*/


kiss_fft_cpx sf_csqrtf (kiss_fft_cpx c);
/*< complex square root >*/


kiss_fft_cpx sf_cdiv(kiss_fft_cpx a, kiss_fft_cpx b);
/*< complex division >*/


kiss_fft_cpx sf_cmul(kiss_fft_cpx a, kiss_fft_cpx b);
/*< complex multiplication >*/


kiss_fft_cpx sf_crmul(kiss_fft_cpx a, float b);
/*< complex by real multiplication >*/


kiss_fft_cpx sf_cneg(kiss_fft_cpx a);
/*< unary minus >*/


kiss_fft_cpx sf_conjf(kiss_fft_cpx z);
/*< complex conjugate >*/


float sf_cabsf(kiss_fft_cpx z);
/*< replacement for cabsf >*/


float sf_cargf(kiss_fft_cpx z);
/*< replacement for cargf >*/


kiss_fft_cpx sf_ctanhf(kiss_fft_cpx z);
/*< complex hyperbolic tangent >*/


kiss_fft_cpx sf_ccosf(kiss_fft_cpx z);
/*< complex cosine >*/


kiss_fft_cpx sf_ccoshf(kiss_fft_cpx z);
/*< complex hyperbolic cosine >*/


kiss_fft_cpx sf_csinf(kiss_fft_cpx z);
/*< complex sine >*/


kiss_fft_cpx sf_csinhf(kiss_fft_cpx z);
/*< complex hyperbolic sine >*/


kiss_fft_cpx sf_clogf(kiss_fft_cpx z);
/*< complex natural logarithm >*/


kiss_fft_cpx sf_cexpf(kiss_fft_cpx z);
/*< complex exponential >*/


kiss_fft_cpx sf_ctanf(kiss_fft_cpx z);
/*< complex tangent >*/


kiss_fft_cpx sf_casinf(kiss_fft_cpx z);
/*< complex hyperbolic arcsine >*/


kiss_fft_cpx sf_cacosf(kiss_fft_cpx z);
/*< complex hyperbolic arccosine >*/


kiss_fft_cpx sf_catanf(kiss_fft_cpx z);
/*< complex arctangent >*/


kiss_fft_cpx sf_catanhf(kiss_fft_cpx z);
/*< complex hyperbolic arctangent >*/


kiss_fft_cpx sf_casinhf(kiss_fft_cpx z);
/*< complex hyperbolic sine >*/


kiss_fft_cpx sf_cacoshf(kiss_fft_cpx z);
/*< complex hyperbolic cosine >*/


kiss_fft_cpx sf_cpowf(kiss_fft_cpx a, kiss_fft_cpx b);
/*< complex power >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ccdstep_h
#define _sf_ccdstep_h




void sf_ccdstep_init(void);
/*< initialize internal storage >*/


void sf_ccdstep_close(void);
/*< free internal storage >*/


void sf_ccdstep(bool forget          /* restart flag */, 
	       int nx               /* model size */, 
	       int ny               /* data size */, 
	       sf_complex* x        /* current model [nx] */, 
	       const sf_complex* g  /* gradient [nx] */, 
	       sf_complex* rr       /* data residual [ny] */, 
	       const sf_complex* gg /* conjugate gradient [ny] */);
/*< Step of conjugate-direction iteration. 
  The data residual is rr = A x - dat
>*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ccgstep_h
#define _sf_ccgstep_h




void sf_ccgstep( bool forget             /* restart flag */, 
		 int nx                  /* model size */, 
		 int ny                  /* data size */, 
		 sf_complex* x        /* current model [nx] */,  
		 const sf_complex* g  /* gradient [nx] */, 
		 sf_complex* rr       /* data residual [ny] */,
		 const sf_complex* gg /* conjugate gradient [ny] */);
/*< Step of Claerbout's conjugate-gradient iteration for complex operators. 
  The data residual is rr = A x - dat
>*/


void sf_ccgstep_close (void);
/*< Free allocated space. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cconjgrad_h
#define _sf_cconjgrad_h




void sf_cconjgrad_init(int np1     /* preconditioned size */, 
		       int nx1     /* model size */, 
		       int nd1     /* data size */, 
		       int nr1     /* residual size */, 
		       float eps1  /* scaling */,
		       float tol1  /* tolerance */, 
		       bool verb1  /* verbosity flag */, 
		       bool hasp01 /* if has initial model */);
/*< solver constructor >*/


void sf_cconjgrad_close(void);
/*< Free allocated space >*/


void sf_cconjgrad(sf_coperator prec     /* data preconditioning */, 
		  sf_coperator oper     /* linear operator */, 
		  sf_coperator shape    /* shaping operator */, 
		  sf_complex* p         /* preconditioned model */, 
		  sf_complex* x         /* estimated model */, 
		  const sf_complex* dat /* data */, 
		  int niter             /* number of iterations */);
/*< Conjugate gradient solver with shaping >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ccopy_h
#define _sf_ccopy_h




void sf_ccopy_lop (bool adj, bool add, int nx, int ny, 
		   sf_complex* xx, sf_complex* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cell_h
#define _sf_cell_h




void sf_cell1_intersect (float a, float x, float dy, float p, 
			 float *sx, int *jx);
/*< intersecting a straight ray with cell boundaries >*/


float sf_cell1_update1 (int dim, float s, float v, float *p, const float *g);
/*< symplectic first-order: step 1 >*/


float sf_cell1_update2 (int dim, float s, float v, float *p, const float *g);
/*< symplectic first-order: step 2 >*/


void sf_cell11_intersect2 (float a, float da, 
			const float* p, const float* g, 
			float *sp, int *jp);
/*< intersecting a straight ray with cell boundaries >*/


float sf_cell11_update1 (int dim, float s, float v, float *p, const float *g);
/*< nonsymplectic first-order: step 1 >*/


float sf_cell11_update2 (int dim, float s, float v, float *p, const float *g);
/*< nonsymplectic first-order: step 2 >*/


void sf_cell_intersect (float a, float x, float dy, float p, 
			float *sx, int *jx);
/*< intersecting a parabolic ray with cell boundaries >*/


bool sf_cell_snap (float *z, int *iz, float eps);
/*< round to the nearest boundary >*/


float sf_cell_update1 (int dim, float s, float v, float *p, const float *g);
/*< symplectic second-order: step 1 >*/


float sf_cell_update2 (int dim        /* number of dimensions */, 
		       float s        /* sigma */, 
		       float v        /* slowness */, 
		       float *p       /* in - ?, out - direction */, 
		       const float *g /* slowness gradient */);
/*< symplectic second-order: step 2 >*/


float sf_cell_p2a (float* p);
/*< convert ray parameter to angle >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_celltrace_h
#define _sf_celltrace_h




typedef struct sf_CellTrace *sf_celltrace;
/* abstract data type */


sf_celltrace sf_celltrace_init (bool lsint  /* use local ls interpolation */,
				int order   /* interpolation accuracy */, 
				int nt      /* maximum time steps */,
				int nz      /* depth samples */, 
				int nx      /* lateral samples */, 
				float dz    /* depth sampling */, 
				float dx    /* lateral sampling */, 
				float z0    /* depth origin */, 
				float x0    /* lateral origin */, 
				float* slow /* slowness [nz*nx] */);
/*< Initialize ray tracing object >*/


void sf_celltrace_close (sf_celltrace ct);
/*< Free allocated storage >*/


float sf_cell_trace (sf_celltrace ct, 
		     float* xp    /* position */, 
		     float* p     /* ray parameter */, 
		     int* it      /* steps till boundary */, 
		     float** traj /* trajectory */);
/*< ray trace >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cdstep_h
#define _sf_cdstep_h




void sf_cdstep_init(void);
/*< initialize internal storage >*/


void sf_cdstep_close(void);
/*< free internal storage >*/


void sf_cdstep(bool forget     /* restart flag */, 
	       int nx          /* model size */, 
	       int ny          /* data size */, 
	       float* x        /* current model [nx] */, 
	       const float* g  /* gradient [nx] */, 
	       float* rr       /* data residual [ny] */, 
	       const float* gg /* conjugate gradient [ny] */);
/*< Step of conjugate-direction iteration. 
  The data residual is rr = A x - dat
>*/


void sf_cdstep_diag(int nx, float *res /* [nx] */);
/*< compute diagonal of the model resolution matrix >*/


void sf_cdstep_mat (int nx, float **res /* [nx][nx] */);
/*< compute complete model resolution matrix >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cgstep_h
#define _sf_cgstep_h




void sf_cgstep( bool forget     /* restart flag */, 
		int nx, int ny  /* model size, data size */, 
		float* x        /* current model [nx] */, 
		const float* g  /* gradient [nx] */, 
		float* rr       /* data residual [ny] */, 
		const float* gg /* conjugate gradient [ny] */);
/*< Step of conjugate-gradient iteration. >*/


void sf_cgstep_close (void);
/*< Free allocated space. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_chain_h
#define _sf_chain_h




void sf_chain( sf_operator oper1     /* outer operator */, 
	       sf_operator oper2     /* inner operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd                /* data size */, 
	       int nt                /* intermediate size */, 
	       /*@out@*/ float* mod  /* [nm] model */, 
	       /*@out@*/ float* dat  /* [nd] data */, 
	       float* tmp            /* [nt] intermediate */);
/*< Chains two operators, computing oper1{oper2{mod}} 
  or its adjoint. The tmp array is used for temporary storage. >*/


void sf_cchain( sf_coperator oper1         /* outer operator */, 
		sf_coperator oper2         /* inner operator */, 
		bool adj                   /* adjoint flag */, 
		bool add                   /* addition flag */, 
		int nm                     /* model size */, 
		int nd                     /* data size */, 
		int nt                     /* intermediate size */, 
		/*@out@*/ sf_complex* mod  /* [nm] model */, 
		/*@out@*/ sf_complex* dat  /* [nd] data */, 
		sf_complex* tmp            /* [nt] intermediate */);
/*< Chains two complex operators, computing oper1{oper2{mod}} 
  or its adjoint. The tmp array is used for temporary storage. >*/


void sf_array( sf_operator oper1     /* top operator */, 
	       sf_operator oper2     /* bottom operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd1               /* top data size */, 
	       int nd2               /* bottom data size */, 
	       /*@out@*/ float* mod  /* [nm] model */, 
	       /*@out@*/ float* dat1 /* [nd1] top data */, 
	       /*@out@*/ float* dat2 /* [nd2] bottom data */);
/*< Constructs an array of two operators, 
  computing {oper1{mod},oper2{mod}} or its adjoint. >*/


void sf_carray( sf_coperator oper1     /* top operator */, 
	       sf_coperator oper2     /* bottom operator */, 
	       bool adj              /* adjoint flag */, 
	       bool add              /* addition flag */, 
	       int nm                /* model size */, 
	       int nd1               /* top data size */, 
	       int nd2               /* bottom data size */, 
	       /*@out@*/ sf_complex* mod  /* [nm] model */, 
	       /*@out@*/ sf_complex* dat1 /* [nd1] top data */, 
	       /*@out@*/ sf_complex* dat2 /* [nd2] bottom data */);
/*< Constructs an array of two complex operators, 
  computing {oper1{mod},oper2{mod}} or its adjoint. >*/


void sf_normal (sf_operator oper /* operator */, 
		bool add         /* addition flag */, 
		int nm           /* model size */, 
		int nd           /* data size */, 
		float *mod       /* [nd] model */, 
		float *dat       /* [nd] data */, 
		float *tmp       /* [nm] intermediate */);
/*< Applies a normal operator (self-adjoint) >*/


void sf_chain3 (sf_operator oper1 /* outer operator */, 
		sf_operator oper2 /* middle operator */, 
		sf_operator oper3 /* inner operator */, 
		bool adj          /* adjoint flag */, 
		bool add          /* addition flag */, 
		int nm            /* model size */, 
		int nt1           /* inner intermediate size */, 
		int nt2           /* outer intermediate size */, 
		int nd            /* data size */, 
		float* mod        /* [nm] model */, 
		float* dat        /* [nd] data */, 
		float* tmp1       /* [nt1] inner intermediate */, 
		float* tmp2       /* [nt2] outer intermediate */);
/*< Chains three operators, computing oper1{oper2{poer3{{mod}}} or its adjoint.
  The tmp1 and tmp2 arrays are used for temporary storage. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_clist_h
#define _sf_clist_h




typedef struct sf_cList *sf_clist;
/* abstract data type */


sf_clist sf_clist_init(void);
/*< create an empty list >*/


void sf_clist_rewind(sf_clist l);
/*< return to the start >*/


int sf_clist_depth(sf_clist l);
/*< return list depth >*/


void sf_clist_add(sf_clist l, sf_complex *g, double gn);
/*< add an entry in the list >*/


void sf_clist_down(sf_clist l, sf_complex **g, double *gn);
/*< extract and entry from the list >*/


void sf_clist_close(sf_clist l);
/*< free allocated storage >*/


void sf_clist_chop(sf_clist l);
/*< free the top entry from the list >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cmatmult_h
#define _sf_cmatmult_h




void sf_cmatmult_init(sf_complex **bb_in);
/*< initialize matrix >*/


void sf_cmatmult_lop (bool adj, bool add, int nx, int ny, 
		      sf_complex *x, sf_complex *y);
/*< operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_conjgrad_h
#define _sf_conjgrad_h




void sf_conjgrad_init(int np1     /* preconditioned size */, 
		      int nx1     /* model size */, 
		      int nd1     /* data size */, 
		      int nr1     /* residual size */, 
		      float eps1  /* scaling */,
		      float tol1  /* tolerance */, 
		      bool verb1  /* verbosity flag */, 
		      bool hasp01 /* if has initial model */);
/*< solver constructor >*/


void sf_conjgrad_close(void);
/*< Free allocated space >*/


void sf_conjgrad(sf_operator prec  /* data preconditioning */, 
		 sf_operator oper  /* linear operator */, 
		 sf_operator shape /* shaping operator */, 
		 float* p          /* preconditioned model */, 
		 float* x          /* estimated model */, 
		 float* dat        /* data */, 
		 int niter         /* number of iterations */);
/*< Conjugate gradient solver with shaping >*/


void sf_conjgrad_adj(bool adj /* adjoint flag */,
		     sf_operator oper  /* linear operator */, 
		     sf_operator shape /* shaping operator */, 
		     float* p          /* preconditioned model */, 
		     float* x          /* estimated model */, 
		     float* dat        /* data */, 
		     int niter         /* number of iterations */);
/*< Conjugate gradient solver with shaping and its adjoint. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_conjprec_h
#define _sf_conjprec_h




typedef void (*sf_operator2)(int,float*);


void sf_conjprec_init(int nx1     /* preconditioned size */, 
		      int nr1     /* residual size */, 
		      float eps1  /* scaling */,
		      float tol1  /* tolerance */, 
		      bool verb1  /* verbosity flag */, 
		      bool hasp01 /* if has initial model */);
/*< solver constructor >*/


void sf_conjprec_close(void);
/*< Free allocated space >*/


void sf_conjprec(sf_operator oper  /* linear operator */, 
		 sf_operator2 prec /* preconditioning */, 
		 float* p          /* preconditioned */, 
		 float* x          /* model */, 
		 const float* dat  /* data */, 
		 int niter         /* number of iterations */);
/*< Conjugate gradient solver with preconditioning >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_copy_h
#define _sf_copy_h




void sf_copy_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_cosft_h
#define _sf_cosft_h


void sf_cosft_init(int n1_in);
/*< initialize >*/


void sf_cosft_close(void);
/*< free allocated storage >*/


void sf_cosft_frw (float *q /* data */, 
		   int o1   /* first sample */, 
		   int d1   /* step */);
/*< forward transform >*/


void sf_cosft_inv (float *q /* data */, 
		   int o1   /* first sample */, 
		   int d1   /* step */);
/*< inverse transform >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ctriangle_h
#define _sf_ctriangle_h




typedef struct sf_Ctriangle *sf_ctriangle;
/* abstract data type */


sf_ctriangle sf_ctriangle_init (int nbox /* triangle length */, 
				int ndat /* data length */,
				bool box /* if box instead of triangle */);
/*< initialize >*/


void sf_csmooth (sf_ctriangle tr    /* smoothing object */, 
		 int o, int d    /* trace sampling */, 
		 bool der        /* if derivative */,
		 sf_complex *x   /* data (smoothed in place) */);
/*< apply adjoint triangle smoothing >*/


void  sf_ctriangle_close(sf_ctriangle tr);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ctrianglen_h
#define _sf_ctrianglen_h




void sf_ctrianglen_init (int ndim  /* number of dimensions */, 
			int *nbox /* triangle radius [ndim] */, 
			int *ndat /* data dimensions [ndim] */);
/*< initialize >*/


void sf_ctrianglen_lop (bool adj, bool add, int nx, int ny, sf_complex* x, sf_complex* y);
/*< linear operator >*/


void sf_ctrianglen_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_decart_h
#define _sf_decart_h


#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>


void sf_line2cart(int dim         /* number of dimensions */, 
		  const int* nn /* box size [dim] */, 
		  int i         /* line coordinate */, 
		  int* ii       /* cartesian coordinates [dim] */);
/*< Convert line to Cartesian >*/


int sf_cart2line(int dim         /* number of dimensions */, 
		 const int* nn /* box size [dim] */, 
		 const int* ii /* cartesian coordinates [dim] */);
/*< Convert Cartesian to line >*/


int sf_first_index (int i          /* dimension [0...dim-1] */, 
		    int j        /* line coordinate */, 
		    int dim        /* number of dimensions */, 
		    const int *n /* box size [dim] */, 
		    const int *s /* step [dim] */);
/*< Find first index for multidimensional transforms >*/


void sf_large_line2cart(int dim         /* number of dimensions */, 
			const off_t* nn /* box size [dim] */, 
			off_t i         /* line coordinate */, 
			off_t* ii       /* cartesian coordinates [dim] */);
/*< Convert line to Cartesian >*/


off_t sf_large_cart2line(int dim         /* number of dimensions */, 
			 const off_t* nn /* box size [dim] */, 
			 const off_t* ii /* cartesian coordinates [dim] */);
/*< Convert Cartesian to line >*/


off_t sf_large_first_index (int i          /* dimension [0...dim-1] */, 
			    off_t j        /* line coordinate */, 
			    int dim        /* number of dimensions */, 
			    const off_t *n /* box size [dim] */, 
			    const off_t *s /* step [dim] */);
/*< Find first index for multidimensional transforms >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_deriv_h
#define _sf_deriv_h


void sf_deriv_init(int nt1  /* transform length */, 
		   int n1   /* trace length */, 
		   float c1 /* filter parameter */);
/*< initialize >*/


void sf_deriv_close(void);
/*< free allocated storage >*/


void sf_deriv (const float* trace, float* trace2);
/*< derivative operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_divn_h
#define _sf_divn_h




void sf_divn_init(int ndim   /* number of dimensions */, 
		  int nd     /* data size */, 
		  int *ndat  /* data dimensions [ndim] */, 
		  int *nbox  /* smoothing radius [ndim] */, 
		  int niter1 /* number of iterations */,
		  bool verb  /* verbosity */);
/*< initialize >*/


void sf_divn_close (void);
/*< free allocated storage >*/


void sf_divn (float* num, float* den,  float* rat);
/*< smoothly divide rat=num/den >*/


void sf_divne (float* num, float* den,  float* rat, float eps);
/*< smoothly divide rat=num/den with preconditioning >*/


void sf_divn_combine (const float* one, const float* two, float *prod);
/*< compute product of two divisions >*/


void sf_divn_combine_sign (const float* one, const float* two, float *prod);
/*< compute product of two divisions (with a sign) >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_dottest_h
#define _sf_dottest_h




/*------------------------------------------------------------*/
void sf_dot_test(sf_operator oper /* linear operator */, 
		 int nm           /* model size */, 
		 int nd           /* data size */, 
		 double* dot1      /* first output */, 
		 double* dot2      /* second output */);
/*< The dot product test to see if the adjoint is coded correctly.
   In the output dot1[0] shpould be equal to dot1[1] 
   (within machine precision),
   and dot2[0] should be equal to dot2[1]. >*/


/*------------------------------------------------------------*/
void sf_dot_report(double* dot1 /* test w/o add */, 
		   double* dot2 /* test w/  add */);
/*< Dot test report >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_doubint_h
#define _sf_doubint_h




void sf_doubint(bool dble, int n, float *trace /* [n] */);
/*< double integration or causal integration (in place) >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_dtrianglen_h
#define _sf_dtrianglen_h


void sf_dtrianglen_init (int ndim  /* number of dimensions */, 
			 int *nbox /* triangle radius [ndim] */, 
			 int *ndat /* data dimensions [ndim] */);
/*< initialize >*/


void sf_dtrianglen (int ider   /* direction of the derivative */,
		    int nrep   /* how many times to repeat smoothing */,
		    int nderiv /* derivative filter accuracy */,
		    float* data   /* input/output */);
/*< linear operator (derivative with respect to radius) >*/


void sf_dtrianglen_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_edge_h
#define _sf_edge_h


void sf_grad2 (int n          /* data size */, 
	       const float *x /* input trace [n] */, 
	       float *w       /* output gradient squared [n] */);
/*< centered finite-difference gradient >*/


void sf_sobel (int n1, int n2         /* data size */, 
	       float **x              /* input data [n2][n1] */, 
	       float **w1, float **w2 /* output gradient [n2][n1] */);
/*< Sobel's 9-point gradient >*/


void sf_sobel2 (int n1, int n2  /* data size */, 
		float **x        /* input data [n2][n1] */, 
		float **w        /* output gradient squared [n2][n1] */);
/*< Sobel's gradient squared >*/


void sf_sobel32 (int n1, int n2, int n3  /* data size */, 
		 float ***x              /* input data [n3][n2][n1] */, 
		 float ***w              /* output gradient squared */);
/*< Sobel's gradient squared in 3-D>*/


void sf_sobel3 (int dim,                /* number of the gradient component */
		int n1, int n2, int n3  /* data size */, 
		float ***x              /* input data [n3][n2][n1] */, 
		float ***w              /* output gradient component */);
/*< Sobel's gradient squared in 3-D>*/

#endif
#ifndef _sf_defs_h
#define _sf_defs_h

#include <float.h>

#define SF_MAX(a,b) ((a) < (b) ? (b) : (a))
#define SF_MIN(a,b) ((a) < (b) ? (a) : (b))

#define SF_ABS(a)   ((a) >= 0  ? (a) : (-(a)))
#define SF_SIG(a)   ((a) >= 0  ?  1  :  -1 )

#define SF_NINT(x) ((int)((x)>0.0?(x)+0.5:(x)-0.5))

#define SF_ODD(n)  ((n) & 1)
#define SF_EVEN(n) (!(SF_ODD(n)))

#define SF_PI (3.14159265358979323846264338328)

#define SF_EPS FLT_EPSILON
#define SF_HUGE FLT_MAX

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_eno_h
#define _sf_eno_h




typedef struct Eno *sf_eno;
/* abstract data type */


typedef enum {FUNC, DER, BOTH} der;
/* flag values */


sf_eno sf_eno_init (int order /* interpolation order */, 
		    int n     /* data size */);
/*< Initialize interpolation object. >*/


void sf_eno_close (sf_eno ent);
/*< Free internal storage >*/


void sf_eno_set (sf_eno ent, float* c /* data [n] */);
/*< Set the interpolation table. c can be changed or freed afterwords >*/


void sf_eno_set_wstride (sf_eno ent, float* c /* data [n] */, int stride);
/*< Set the interpolation table. c can be changed or freed afterwords >*/


void sf_eno_apply (sf_eno ent, 
		int i     /* grid location */, 
		float x   /* offset from grid */, 
		float *f  /* output data value */, 
		float *f1 /* output derivative */, 
		der what  /* flag of what to compute */);
/*< Apply interpolation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_eno2_h
#define _sf_eno2_h




typedef struct Eno2 *sf_eno2;
/* abstract data type */


sf_eno2 sf_eno2_init (int order      /* interpolation order */, 
		      int n1, int n2 /* data dimensions */);
/*< Initialize interpolation object >*/


void sf_eno2_set (sf_eno2 pnt, float** c /* data [n2][n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_eno2_set1 (sf_eno2 pnt, float* c /* data [n2*n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_eno2_set1_wstride (sf_eno2 pnt, float* c /* data [n2*n1] */, int stride);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_eno2_close (sf_eno2 pnt);
/*< Free internal storage >*/


void sf_eno2_apply (sf_eno2 pnt, 
		    int i, int j     /* grid location */, 
		    float x, float y /* offset from grid */, 
		    float* f         /* output data value */, 
		    float* f1        /* output derivative [2] */,
		    der what         /* what to compute [FUNC,DER,BOTH] */);
/*< Apply interpolation. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_eno3_h
#define _sf_eno3_h




typedef struct Eno3 *sf_eno3;
/* abstract data type */


sf_eno3 sf_eno3_init (int order              /* interpolation order */, 
		      int n1, int n2, int n3 /* data dimensions */);
/*< Initialize interpolation object >*/


void sf_eno3_set (sf_eno3 pnt, float*** c /* data [n3][n2][n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_eno3_set1 (sf_eno3 pnt, float* c /* data [n3*n2*n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_eno3_close (sf_eno3 pnt);
/*< Free internal storage. >*/


void sf_eno3_apply (sf_eno3 pnt, 
		    int i, int j, int k       /* grid location */, 
		    float x, float y, float z /* offsets from grid */,
		    float* f                  /* output data */, 
		    float* f1                 /* output derivative [3] */, 
		    der what                  /* to compute [FUNC|DER|BOTH] */);
/*< Apply interpolation. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_error_h
#define _sf_error_h


void sf_error( const char *format, ... );
/*< Outputs an error message to stderr and terminates the program. 
---
Format and variable arguments follow printf convention. Additionally, a ':' at
the end of format adds system information for system errors. >*/


void sf_warning( const char *format, ... );
/*< Outputs a warning message to stderr. 
---
Format and variable arguments follow printf convention. Additionally, a ':' at
the end of format adds system information for system errors. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_fftlabel_h
#define _sf_fftlabel_h




void sf_fft_unit(int axis         /* axis number */,
		 const char* unit /* input unit */,
		 sf_file out      /* output file */);
/*< Change unit to 1/unit or vice versa >*/


bool sf_fft_label(int axis          /* axis number */,
		  const char* label /* input label */, 
		  sf_file out       /* output file */);
/*< Choose an output label appropriately. 
  Returns false if the label name is not recognized. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_files_h
#define _sf_files_h




int sf_filedims (sf_file file, /*@out@*/ int *n);
/*< Find file dimensions.
--- 
Outputs the number of dimensions dim and a dimension array n[dim] >*/


int sf_largefiledims (sf_file file, /*@out@*/ off_t *n);
/*< Find file dimensions.
--- 
Outputs the number of dimensions dim and a dimension array n[dim] >*/


int sf_memsize();
/*< Returns memory size by:
  1. checking RSFMEMSIZE environmental variable
  2. using hard-coded "def" constant
  >*/


off_t sf_filesize (sf_file file);
/*< Find file size (product of all dimensions) >*/


off_t sf_leftsize (sf_file file, int dim);
/*< Find file size for dimensions greater than dim >*/


void sf_cp(sf_file in, sf_file out);
/*< Copy file in to file out >*/


void sf_rm(const char* filename, bool force, bool verb, bool inquire);
/*< Remove an RSF file.
---
force, verb, and inquire flags should behave similar to the corresponding flags in the Unix "rm" command. >*/


off_t sf_shiftdim(sf_file in, sf_file out, int axis);
/*< shift grid after axis by one dimension forward >*/


off_t sf_shiftdim2(sf_file in, sf_file out, int axis);
/*< shift grid after axis by two dimension forward >*/


off_t sf_shiftdimn(sf_file in, sf_file out, int axis, int n);
/*< shift grid after axis by n dimension forward >*/


off_t sf_unshiftdim(sf_file in, sf_file out, int axis);
/*< shift grid after axis by one dimension backward >*/


off_t sf_unshiftdim2(sf_file in, sf_file out, int axis);
/*< shift grid after axis by two dimension backward >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_freqfilt_h
#define _sf_freqfilt_h




void sf_freqfilt_init(int nfft1 /* time samples (possibly padded) */, 
		      int nw1   /* frequency samples */);
/*< Initialize >*/


void sf_freqfilt_set(float *filt /* frequency filter [nw] */);
/*< Initialize filter (zero-phase) >*/


/* #ifndef __cplusplus */


void sf_freqfilt_cset(kiss_fft_cpx *filt /* frequency filter [nw] */);
/*< Initialize filter >*/


void sf_freqfilt_close(void);
/*< Free allocated storage >*/


void sf_freqfilt(int nx, float* x);
/*< Filtering in place >*/


void sf_freqfilt_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< Filtering as linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_freqfilt2_h
#define _sf_freqfilt2_h




void sf_freqfilt2_init(int n1, int n2 /* data dimensions */, 
		       int nw1        /* number of frequencies */);
/*< initialize >*/


void sf_freqfilt2_set(float **filt);
/*< set the filter >*/


void sf_freqfilt2_close(void);
/*< free allocated storage >*/


void sf_freqfilt2_spec (const float* x /* input */, float** y /* spectrum */);
/*< compute 2-D spectrum >*/


void sf_freqfilt2_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear filtering operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ftutil_h
#define _sf_ftutil_h




typedef struct sf_fft *sf_fft3d;


struct sf_fft{
    int n1,n2,n3;
    kiss_fft_cfg forw; /* forward transform */
    kiss_fft_cfg invs; /* inverse transform */
    float scale;
    kiss_fft_cpx *trace;
};


typedef struct sf_ompfft *ompfft3d;


struct sf_ompfft{
    int n1,n2,n3;
    int ompnth;
    kiss_fft_cfg *forw; /* forward transform */
    kiss_fft_cfg *invs; /* inverse transform */
    float scale;
    kiss_fft_cpx **trace;
};


typedef struct sf_sft *sft3d;


struct sf_sft{
    float o,d;
    sf_complex *www;
};


typedef struct sf_ompsft *ompsft3d;


struct sf_ompsft{
    float o,d;
    sf_complex **www;
};


/*------------------------------------------------------------*/
sf_fft3d sf_fft3a1_init(int n1_, 
		     int n2_, 
		     int n3_);
/*< initialize FFT on axis 1 >*/


/*------------------------------------------------------------*/
ompfft3d sf_ompfft3a1_init(int n1_, 
			   int n2_, 
			   int n3_, 
			   int ompnth_);
/*< initialize FFT on axis 1 >*/


/*------------------------------------------------------------*/
sf_fft3d sf_fft3a2_init(int n1_, 
		     int n2_, 
		     int n3_);
/*< initialize FFT on axis 2 >*/


/*------------------------------------------------------------*/
ompfft3d sf_ompfft3a2_init(int n1_, 
			   int n2_, 
			   int n3_,
			   int ompnth_);
/*< initialize FFT on axis 2 >*/


/*------------------------------------------------------------*/
sf_fft3d sf_fft3a3_init(int n1_, 
		     int n2_, 
		     int n3_);
/*< initialize FFT on axis 3 >*/


/*------------------------------------------------------------*/
ompfft3d sf_ompfft3a3_init(int n1_, 
			   int n2_, 
			   int n3_,
			   int ompnth_);
/*< initialize FFT on axis 3 >*/


/*------------------------------------------------------------*/
void sf_fft3a1_close(sf_fft3d fft);
/*< free allocated storage for FFT on axis 1 >*/


/*------------------------------------------------------------*/
void sf_ompfft3a1_close(ompfft3d fft);
/*< free allocated storage for FFT on axis 1 >*/


/*------------------------------------------------------------*/
void sf_fft3a2_close(sf_fft3d fft);
/*< free allocated storage for FFT on axis 2 >*/


/*------------------------------------------------------------*/
void sf_ompfft3a2_close(ompfft3d fft);
/*< free allocated storage for FFT on axis 2 >*/


/*------------------------------------------------------------*/
void sf_fft3a3_close(sf_fft3d fft);
/*< free allocated storage for FFT on axis 3 >*/


/*------------------------------------------------------------*/
void sf_ompfft3a3_close(ompfft3d fft);
/*< free allocated storage for FFT on axis 3 >*/


/*------------------------------------------------------------*/
void sf_fft3a1(bool inv           /* inverse/forward flag */, 
	       kiss_fft_cpx ***pp /* [n1][n2][n3] */,
	       sf_fft3d fft);
/*< apply FFT on axis 1 >*/


/*------------------------------------------------------------*/
void sf_ompfft3a1(bool inv           /* inverse/forward flag */, 
		  kiss_fft_cpx ***pp /* [n1][n2][n3] */,
		  ompfft3d fft,
		  int ompith);
/*< apply FFT on axis 1 >*/


/*------------------------------------------------------------*/
void sf_fft3a2(bool inv           /* inverse/forward flag */, 
	       kiss_fft_cpx ***pp /* [n1][n2][n3] */,
	       sf_fft3d fft);
/*< apply FFT on axis 2 >*/


/*------------------------------------------------------------*/
void sf_ompfft3a2(bool inv           /* inverse/forward flag */, 
		  kiss_fft_cpx ***pp /* [n1][n2][n3] */,
		  ompfft3d fft,
		  int ompith);
/*< apply FFT on axis 2 >*/


/*------------------------------------------------------------*/
void sf_fft3a3(bool inv           /* inverse/forward flag */, 
	       kiss_fft_cpx ***pp /* [n1][n2][n3] */,
	       sf_fft3d fft);
/*< apply FFT on axis 3 >*/


/*------------------------------------------------------------*/
void sf_ompfft3a3(bool inv           /* inverse/forward flag */, 
		  kiss_fft_cpx ***pp /* [n1][n2][n3] */,
		  ompfft3d fft,
		  int ompith);
/*< apply FFT on axis 3 >*/


/*------------------------------------------------------------*/
void sf_cnt3a1(sf_complex ***pp,
	       sf_fft3d fft);
/*< apply centering on axis 1 >*/


/*------------------------------------------------------------*/
void sf_cnt3a2(sf_complex ***pp,
	       sf_fft3d fft);
/*< apply centering on axis 2 >*/


/*------------------------------------------------------------*/
void sf_cnt3a3(sf_complex ***pp,
	       sf_fft3d fft);
/*< apply centering on axis 3>*/


/*------------------------------------------------------------*/
sft3d sf_sft3_init(int n,
		   float o,
		   float d);
/*< origin shift (assumes no centering) >*/


/*------------------------------------------------------------*/
ompsft3d sf_ompsft3_init(int n,
			 float o,
			 float d,
			 int ompnth);
/*< origin shift (assumes no centering) >*/


/*------------------------------------------------------------*/
void sf_sft3_reset(int n,
		   float o,
		   float d,
		   sft3d sft);
/*< reset shift parameters >*/


/*------------------------------------------------------------*/
void sf_ompsft3_reset(int n,
		      float o,
		      float d,
		      ompsft3d sft,
		      int ompith);
/*< reset shift parameters >*/


/*------------------------------------------------------------*/
void sf_sft3_close(sft3d sft);
/*< close shift >*/


/*------------------------------------------------------------*/
void sf_ompsft3_close(ompsft3d sft);
/*< close shift >*/


/*------------------------------------------------------------*/
void sf_sft3a3(sf_complex ***pp,
	       sft3d sft,
	       sf_fft3d fft);
/*< apply shift on axis 3 >*/


/*------------------------------------------------------------*/
void sf_ompsft3a3(sf_complex ***pp,
		  ompsft3d sft,
		  ompfft3d fft,
		  int ompith);
/*< apply shift on axis 3 >*/


/*------------------------------------------------------------*/
void sf_sft3a2(sf_complex ***pp,
	       sft3d sft,
	       sf_fft3d fft);
/*< apply shift on axis 2 >*/


/*------------------------------------------------------------*/
void sf_ompsft3a2(sf_complex ***pp,
		  ompsft3d sft,
		  ompfft3d fft,
		  int ompith);
/*< apply shift on axis 2 >*/


/*------------------------------------------------------------*/
void sf_sft3a1(sf_complex ***pp,
	       sft3d sft,
	       sf_fft3d fft);
/*< apply shift on axis 1 >*/


/*------------------------------------------------------------*/
void sf_ompsft3a1(sf_complex ***pp,
		  ompsft3d sft,
		  ompfft3d fft,
		  int ompith);
/*< apply shift on axis 1 >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_fzero_h
#define _sf_fzero_h




float sf_zero (float (*func)(float) /* function f(x) */, 
	       float a, float b     /* interval */, 
	       float fa, float fb   /* f(a) and f(b) */,
	       float toler          /* tolerance */, 
	       bool verb            /* verbosity flag */);
/*< Return c such that f(c)=0 (within tolerance). 
  fa and fb should have different signs. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_gaussel_h
#define _sf_gaussel_h


void sf_gaussel_init (int size);
/*< initialize >*/


void sf_gaussel_close (void);
/*< free allocated storage >*/


void sf_gaussel_solve (float **a       /* matrix [size][size] */, 
		       const float *b  /* rhs [size] */, 
		       float *x        /* solution [size] */);
/*< solve a*x = b >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_simtab_h
#define _sf_simtab_h


#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE
#endif
#include <sys/types.h>
#include <unistd.h>


#include <stdio.h>




#define SF_EOL '\014'
#define SF_EOT '\004'


typedef struct sf_SimTab *sf_simtab; /* Simbol Table structure */


sf_simtab sf_simtab_init(int size);
/*< Create simbol table. >*/


void sf_simtab_close(sf_simtab table);
/*< Free allocated memory >*/


void sf_simtab_enter(sf_simtab table, const char *key, const char* val);
/*< Add an entry key=val to the table >*/


char *sf_simtab_get(sf_simtab table, const char *key);
/*< extract a value from the table >*/


bool sf_simtab_getint (sf_simtab table, const char* key,/*@out@*/ int* par);
/*< extract an int parameter from the table >*/


bool sf_simtab_getlargeint (sf_simtab table, const char* key,/*@out@*/ off_t* par);
/*< extract a sf_largeint parameter from the table >*/


bool sf_simtab_getfloat (sf_simtab table, const char* key,/*@out@*/ float* par);
/*< extract a float parameter from the table >*/


bool sf_simtab_getdouble (sf_simtab table, const char* key,/*@out@*/ double* par);
/*< extract a double parameter from the table >*/


bool sf_simtab_getfloats (sf_simtab table, const char* key,
			  /*@out@*/ float* par,size_t n);
/*< extract a float array parameter from the table >*/


char* sf_simtab_getstring (sf_simtab table, const char* key);
/*< extract a string parameter from the table >*/


bool sf_simtab_getbool (sf_simtab table, const char* key,/*@out@*/ bool *par);
/*< extract a bool parameter from the table >*/


bool sf_simtab_getbools (sf_simtab table, const char* key,
			 /*@out@*/bool *par,size_t n);
/*< extract a bool array parameter from the table >*/


bool sf_simtab_getints (sf_simtab table, const char* key,
			/*@out@*/ int *par,size_t n);
/*< extract an int array parameter from the table >*/


bool sf_simtab_getstrings (sf_simtab table, const char* key,
			   /*@out@*/ char **par,size_t n);
/*< extract a string array parameter from the table >*/


void sf_simtab_put (sf_simtab table, const char *keyval);
/*< put a key=val string to the table >*/


void sf_simtab_string (sf_simtab table, char* string);
/*< extract parameters from a string >*/


void sf_simtab_input (sf_simtab table, FILE* fp, FILE* out);
/*< extract parameters from a file >*/


void sf_simtab_output (sf_simtab table, FILE* fp);
/*< output parameters to a file >*/


void sf_simtab_expand (sf_simtab table, const sf_simtab expand);
/*< expand table from another table >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_getpar_h
#define _sf_getpar_h




bool sf_stdin(void);
/*< returns true if there is an input in stdin >*/


void sf_init(int argc,char *argv[]);
/*< initialize parameter table from command-line arguments >*/


void sf_parenv(const char *string);
/*< add parameters from an environmental variable >*/


void sf_parclose (void);
/*< close parameter table and free space >*/


void sf_parout (FILE *file);
/*< write the parameters to a file >*/


char* sf_getprog (void);
/*< returns name of the running program >*/


char* sf_getuser (void);
/*< returns user name >*/


char* sf_gethost (void);
/*< returns host name >*/


char* sf_getcdir (void);
/*< returns current directory >*/


bool sf_getint (const char* key,/*@out@*/ int* par);
/*< get an int parameter from the command line >*/


bool sf_getlargeint (const char* key,/*@out@*/ off_t* par);
/*< get a large int parameter from the command line >*/


bool sf_getints (const char* key,/*@out@*/ int* par,size_t n);
/*< get an int array parameter (comma-separated) from the command line >*/


bool sf_getfloat (const char* key,/*@out@*/ float* par);
/*< get a float parameter from the command line >*/


bool sf_getdouble (const char* key,/*@out@*/ double* par);
/*< get a double parameter from the command line >*/


bool sf_getfloats (const char* key,/*@out@*/ float* par,size_t n);
/*< get a float array parameter from the command line >*/


char* sf_getstring (const char* key);
/*< get a string parameter from the command line >*/


bool sf_getstrings (const char* key,/*@out@*/ char** par,size_t n);
/*< get a string array parameter from the command line >*/


bool sf_getbool (const char* key,/*@out@*/ bool* par);
/*< get a bool parameter from the command line >*/


bool sf_getbools (const char* key,/*@out@*/ bool* par,size_t n);
/*< get a bool array parameter from the command line >*/


sf_simtab sf_getpars (void);
/*< provide access to the parameter table >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_gmres_h
#define _sf_gmres_h




void sf_gmres_init(int nx      /* data size */, 
		   int restart /* memory */);
/*< initialize >*/


void sf_gmres_close(void);
/*< free allocated storage >*/


void sf_gmres (const float *f                                         /* data */, 
	       float *x                                               /* estimated model */,
	       void (*myatimes) (int, const float *, float *, void *) /* operator */,
	       void * user_data                                       /* internal data */,
	       int itmax                                              /* number of iterations */, 
	       float tol                                              /* tolerance */, 
	       bool verb                                              /* verbosity */);
/*< GMRES solver >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_grad2fill_h
#define _sf_grad2fill_h




void sf_grad2fill_init (int m1, int m2);
/*< Initialize with data dimensions >*/


void sf_grad2fill_close (void);
/*< Free allocate storage >*/


void sf_grad2fill(int niter   /* number of iterations */, 
	       float* mm   /* estimated model */, 
	       bool *known /* mask */);
/*< Run optimization >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_halfint_h
#define _sf_halfint_h




void sf_halfint_init (bool inv  /* differentiation or integration */, 
		      int n1    /* trace length */, 
		      float rho /* regularization */);
/*< Initialize >*/


void sf_halfint_lop(bool adj, bool add, int n1, int n2, float *xx, float *yy);
/*< linear operator >*/


void sf_halfint (bool adj, float* x /* [n] */);
/*< Integrate in place >*/


void sf_halfint_close(void);
/*< Free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_helix_h
#define _sf_helix_h




typedef struct sf_helixfilter {
    int     nh;
    float* flt;
    int*   lag;
    bool*  mis;
    float   h0;
} *sf_filter;


/*------------------------------------------------------------*/
sf_filter sf_allocatehelix( int nh);
/*< allocation >*/


/*------------------------------------------------------------*/
void sf_deallocatehelix( sf_filter aa);
/*< deallocation >*/


/*------------------------------------------------------------*/
void sf_displayhelix( sf_filter aa);
/*< display filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_helicon_h
#define _sf_helicon_h




void sf_helicon_init( sf_filter bb);
/*<  Initialized with the filter. >*/


void sf_helicon_lop( bool adj, bool add, 
		     int nx, int ny, float* xx, float*yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_hilbert_h
#define _sf_hilbert_h


void sf_hilbert_init(int nt1  /* trace length */, 
		     int n1   /* transform length */, 
		     float c1 /* filter parameter */);
/*< initialize >*/


void sf_hilbert_close(void);
/*< free allocated storage >*/


void sf_hilbert (const float* trace, float* trace2);
/*< transform >*/


void sf_hilbert4 (const float* trace, float* trace2);
/*< transform - kind 4 filter >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_igrad1_h
#define _sf_igrad1_h


void  sf_igrad1_lop(bool adj, bool add, 
		    int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_igrad2_h
#define _sf_igrad2_h




void sf_igrad2_init (int n1_in, int n2_in);
/*< initialize with data dimensions >*/


void sf_igrad2_lop (bool adj, bool add, int np, int nr, float* p, float* r);
/*< linear operator, r[n1*n2*2] is the gradient of p[n1*n2] >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_impl2_h
#define _sf_impl2_h


void sf_impl2_init (float r1, float r2   /* radius */, 
		 int n1_in, int n2_in /* data size */, 
		 float tau            /* duration */, 
		 float pclip          /* percentage clip */, 
		 bool up_in           /* weighting case */,
		 bool verb_in         /* verbosity flag */,
		 float *dist_in       /* optional distance function */,
		 int nsnap_in         /* number of snapshots */,
		 sf_file snap_in      /* snapshot file */);
/*< initialize >*/


void sf_impl2_close (void);
/*< free allocated storage >*/


void sf_impl2_set(float ** x);
/*< compute weighting function >*/


void sf_impl2_apply (float **x, bool set, bool adj);
/*< apply diffusion >*/


void sf_impl2_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_interp_h
#define _sf_interp_h


typedef void (*sf_interpolator)(float,int,float*);
/* generic interpolation interface */


void sf_bin_int (float x, int n, float* w);
/*< nearest neighbor >*/


void sf_lin_int (float x, int n, float* w);
/*< linear >*/


void sf_lg_int (float x, int n, float* w);
/*< Lagrangian >*/


void sf_taylor (float x, int n, float* w);
/*< Taylor >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_int1_h
#define _sf_int1_h




void  sf_int1_init (float* coord               /* cooordinates [nd] */, 
		    float o1, float d1, int n1 /* axis */, 
		    sf_interpolator interp     /* interpolation function */, 
		    int nf_in                  /* interpolator length */, 
		    int nd_in                  /* number of data points */,
		    float tau                  /* interpolation shift */);
/*< initialize >*/


void  sf_int1_lop (bool adj, bool add, int nm, int ny, float* x, float* ord);
/*< linear operator >*/


void  sf_cint1_lop (bool adj, bool add, int nm, int ny, sf_complex* x, sf_complex* ord);
/*< linear operator for complex numbers >*/


void sf_int1_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_int2_h
#define _sf_int2_h






void  sf_int2_init (float** coord          /* coordinates [nd][2] */, 
		    float o1, float o2, 
		    float d1, float d2,
		    int   n1, int   n2     /* axes */, 
		    sf_interpolator interp /* interpolation function */, 
		    int nf_in              /* interpolator length */, 
		    int nd_in              /* number of data points */);
/*< initialize >*/


void  sf_int2sh_init (float** coord          /* coordinates [nd][2] */, 
		    float o1, float o2, 
		    float d1, float d2,
		    int   n1, int   n2     /* axes */, 
		    sf_interpolator interp /* interpolation function */, 
		    int nf_in              /* interpolator length */, 
		    int nd_in              /* number of data points */);
/*< initialize with shift >*/


void  sf_int2_lop (bool adj, bool add, int nm, int ny, float* x, float* ord);
/*< linear operator >*/


void sf_int2_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_int3_h
#define _sf_int3_h






void  sf_int3_init (float** coord          /* coordinates [nd][3] */, 
		    float o1, float o2, float o3,
		    float d1, float d2, float d3,
		    int   n1, int   n2,   int n3 /* axes */, 
		    sf_interpolator interp /* interpolation function */, 
		    int nf_in              /* interpolator length */, 
		    int nd_in              /* number of data points */);
/*< initialize >*/


void  sf_int3_lop (bool adj, bool add, int nm, int ny, float* mm, float* dd);
/*< linear operator >*/


void int3_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_interp_spline_h
#define _sf_interp_spline_h


void sf_spline_int (float x, int n, float* w);
/*< interpolation function >*/


void sf_spline_der (float x, int n, float* w);
/*< derivative computation >*/


void sf_spline4_int (float x, float* w);
/*< Cubic spline interpolation >*/


void sf_spline4_der (float x, float* w);
/*< Cubic spline derivative >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_irls_h
#define _sf_irls_h


void sf_irls_init(int n);
/*< Initialize with data size >*/


void sf_irls_close(void);
/*< free allocated storage >*/


void sf_l1 (int n, const float *res, float *weight);
/*< weighting for L1 norm >*/


void sf_cauchy (int n, const float *res, float *weight);
/*< weighting for Cauchy norm >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_llist_h
#define _sf_llist_h


typedef struct sf_List *sf_list;
/* abstract data type */


sf_list sf_llist_init(void);
/*< create an empty list >*/


void sf_llist_rewind(sf_list l);
/*< return to the start >*/


int sf_llist_depth(sf_list l);
/*< return list depth >*/


void sf_llist_add(sf_list l, float *g, double gn);
/*< add an entry in the list >*/


void sf_llist_down(sf_list l, float **g, double *gn);
/*< extract and entry from the list >*/


void sf_llist_close(sf_list l);
/*< free allocated storage >*/


void sf_llist_chop(sf_list l);
/*< free the top entry from the list >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_lsint2_h
#define _sf_lsint2_h




typedef struct LSint2 *sf_lsint2;
/* abstract data type */


sf_lsint2 sf_lsint2_init (int n1, int n2 /* data dimensions */);
/*< Initialize interpolation object >*/


void sf_lsint2_set (sf_lsint2 pnt, float** c /* data [n2][n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_lsint2_close (sf_lsint2 pnt);
/*< Free internal storage >*/


void sf_lsint2_set1 (sf_lsint2 pnt, float* c /* data [n2*n1] */);
/*< Set the interpolation table. c can be changed or freed afterwords. >*/


void sf_lsint2_apply (sf_lsint2 pnt, 
		      int i, int j     /* grid location */, 
		      float x, float y /* offset from grid */, 
		      float* f         /* output data value */, 
		      float* f1        /* output derivative [2] */,
		      der what         /* what to compute [FUNC,DER,BOTH] */);
/*< Apply interpolation. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_mask_h
#define _sf_mask_h




void sf_mask_init(const bool *m_in);
/*< initialize with mask >*/


void sf_mask_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/


void sf_cmask_lop(bool adj, bool add, int nx, int ny, sf_complex *x, sf_complex *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_math1_h
#define _sf_math1_h




void sf_math_evaluate (int     len  /* stack length */, 
		       int     nbuf /* buffer length */, 
		       float** fbuf /* number buffers */, 
		       float** fst  /* stack */);
/*< Evaluate a mathematical expression from stack (float numbers) >*/


void sf_int_math_evaluate (int   len  /* stack length */, 
			   int   nbuf /* buffer length */, 
			   int** ibuf /* number buffers */, 
			   int** ist  /* stack */);
/*< Evaluate a mathematical expression from stack (integer numbers) >*/


void sf_complex_math_evaluate (int          len  /* stack length */, 
			       int          nbuf /* buffer length */, 
			       sf_complex** cbuf /* number buffers */, 
			       sf_complex** cst  /* stack */);
/*< Evaluate a mathematical expression from stack (complex numbers) >*/


size_t sf_math_parse (char*       output /* expression */, 
		      sf_file     out    /* parameter file */,
		      sf_datatype datatype);
/*< Parse a mathematical expression, returns stack length >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_matmult2_h
#define _sf_matmult2_h




void sf_matmult2_init (float** bb);
/*< initialize with a pointer to a matrix >*/


void sf_matmult2_lop (bool adj, bool add, 
		      int nx, int ny, float* x, float*y);
/*< linear operator, no adjoint >*/


void sf_matmult2 (int nx, const float* x, float* y, void* mat);
/*< square linear operator, no adjoint >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_multidivn_h
#define _sf_multidivn_h




void sf_multidivn_init(int nw       /* number of components */, 
		       int ndim     /* number of dimensions */, 
		       int n        /* data size */, 
		       int *ndat    /* data dimensions [ndim] */, 
		       int *nbox    /* smoothing radius [ndim] */,
		       float* den   /* denominator [nw*nd] */,
		       sf_filter aa /* data filter */,
		       bool verb    /* verbosity flag */);
/*< initialize >*/


void sf_multidivn_close (void);
/*< free allocated storage >*/


void sf_multidivn (float* num  /* numerator */, 
		   float* rat  /* ratio */, 
		   int niter   /* number of iterations */);
/*< smoothly divide num/rat >*/


void sf_multidivn_adj (bool adj /* adjoint flag */,
		       float* num  /* numerator */, 
		       float* rat  /* ratio */, 
		       int niter   /* number of iterations */);
/*< smoothly divide num/rat >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_multidivnL1_h
#define _sf_multidivnL1_h




void sf_multidivnL1_init(int nw       /* number of components */,
		       int ndim     /* number of dimensions */, 
		       int n1        /* data size */,
		       int *ndat    /* data dimensions [ndim] */, 
		       int *nbox    /* smoothing radius [ndim] */,
		       float* den   /* denominator [nw*nd] */,
		       sf_filter aa /* data filter */,
		       float perc   /* percentage for sharpening */,
		       bool verb1    /* verbosity flag */);
/*< initialize >*/


void sf_multidivnL1_close (void);
/*< free allocated storage >*/


void sf_multidivnL1 (float* num  /* numerator [data]*/,
		   float* rat  /* ratio [model]*/,
		   int niter   /* number of POCS iterations */,
		   int liter   /* number of shaping CG iteration */);
/*< smoothly L1 divide num/rat >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_neighbors_h
#define _sf_neighbors_h


void sf_neighbors_init (int *in1     /* status flag [n[0]*n[1]*n[2]] */, 
			float *rdx1  /* grid sampling [3] */, 
			int *n1      /* grid samples [3] */, 
			int order1   /* accuracy order */, 
			float *time1 /* traveltime [n[0]*n[1]*n[2]] */);
/*< Initialize >*/


int  sf_neighbours(int i);
/*< Update neighbors of gridpoint i, return number of updated points >*/


int  sf_neighbours2(int i);
/*< Update neighbors of gridpoint i, return number of updated points >*/


int sf_neighbors_distance(int np         /* number of points */,
			  float *vv1     /* slowness squared */,
			  float **points /* point coordinates[np][3] */,
			  float *d       /* grid sampling [3] */,
			  float *o       /* grid origin [3] */);
/*< initialize distance computation >*/


int sf_neighbors_nearsource(float* xs   /* source location [3] */, 
			    int* b      /* constant-velocity box around it [3] */, 
			    float* d    /* grid sampling [3] */, 
			    float* vv1  /* slowness [n[0]*n[1]*n[2]] */, 
			    bool *plane /* if plane-wave source */);
/*< initialize the source >*/


int sf_neighbors_nearsource_rtp(float* xs   /* source location [3] */, 
			    int* b      /* constant-velocity box around it [3] */, 
			    float* d    /* grid sampling [3] */, 
			    float* vv1  /* slowness [n[0]*n[1]*n[2]] */, 
			    bool *plane /* if plane-wave source */);
/*< initialize the source in the spherical case (rtp), added by YC, Apr, 2022 >*/


int sf_neighbors_surface(float* vv1  /* slowness [n[0]*n[1]*n[2]] */,
			 float* tt0  /* surface traveltime [n[1]*n[2]] */,
			 bool forw /* forward or backward continuation */);
/*< initialize the source at the surface >*/


int sf_neighbors_mask(float* vv1  /* slowness [n[0]*n[1]*n[2]] */,
		      float* tref /* reference traveltime [n[0]*n[1]*n[2]] */,
		      bool* known /* where known [n[0]*n[1]*n[2]] */,
		      bool forw   /* forward or backward continuation */);
/*< initialize the source using a mask >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ntriangle_h
#define _sf_ntriangle_h


typedef struct sf_Ntriangle *sf_ntriangle;
/* abstract data type */


sf_ntriangle sf_ntriangle_init (int nbox /* maximum triangle length */, 
			     int ndat /* data length */);
/*< initialize >*/


void sf_nsmooth (sf_ntriangle tr   /* smoothing object */, 
		 int o, int d   /* sampling */, 
		 bool der       /* derivative flag */, 
		 const float *t /* triangle lengths */, 
		 const float *s /* triangle shifts */,
		 float *x       /* data (smoothed in place) */);
/*< smooth >*/


void sf_nsmooth2 (sf_ntriangle tr   /* smoothing object */, 
		  int o, int d   /* sampling */, 
		  bool der       /* derivative flag */, 
		  const float *t /* triangle lengths */,
		  const float *s /* triangle shifts */,
		  float *x       /* data (smoothed in place) */);
/*< alternative smooth >*/


void sf_ndsmooth (sf_ntriangle tr /* smoothing derivative object */, 
		  int o, int d /* sampling. o: starting index, d: stride in samples for 1/2/3rd dimension; all refer to a correct index in a 1D vector  */, 
		  bool der     /* derivative flag */, 
		  const float *t /* triangle lengths */, 
		  const float *s /* triangle shifts */,
		  float *x     /* data (smoothed in place) */);
/*< smooth derivative >*/


void  sf_ntriangle_close(sf_ntriangle tr);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_ntrianglen_h
#define _sf_ntrianglen_h


void sf_ntrianglen_init (int ndim    /* number of dimensions */, 
		      int *nbox   /* triangle radius [ndim] */, 
		      int *ndat   /* data dimensions [ndim] */,
		      float **len /* triangle lengths [ndim][nd] */,
                      float **sft /* triangle shifts [ndim][nd] */,
		      int repeat  /* repeated smoothing */);
/*< initialize >*/


void sf_ntrianglen_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/


void sf_ntrianglen_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_omptools_h
#define _sf_omptools_h


/*------------------------------------------------------------*/
int omp_init(void);
/*< init OMP parameters >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_parallel_h
#define _sf_parallel_h




#define SF_CMDLEN 4096


char** sf_split(sf_file inp          /* input file */, 
		int axis             /* split axis */,
		int nodes            /* number of CPUs */,
		int *tasks           /* number of tasks */,
		int ndim, off_t *n   /* [ndim] file dimensions */, 
		int argc, char**argv /* command-line arguments */);
/*< split the input file along the specified axis
  and generate parallel system commands >*/


void sf_out(sf_file out        /* output file */,
	    int jobs           /* number of jobs */,
	    int axis           /* join axis */,
	    const char *iname  /* name of the input file */);
/*< prepare output >*/


void sf_join(sf_file out /* output file */,
	     int axis    /* axis to join */,
	     int jobs    /* number of jobs */);
/*< join outputs >*/


void sf_add(sf_file out /* output file */,
	    int jobs    /* number of jobs */);
/*< add outputs >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_point_h
#define _sf_point_h




#define DST2d(A,B) ( (B.x-A.x)*(B.x-A.x) + \
                     (B.z-A.z)*(B.z-A.z) ) 
#define DST3d(A,B) ( (B.x-A.x)*(B.x-A.x) + \
                     (B.y-A.y)*(B.y-A.y) + \
                     (B.z-A.z)*(B.z-A.z) ) 


#define JAC2d(O,A,B) ( (A.x-O.x)*(B.z-O.z)-(B.x-O.x)*(A.z-O.z) )


typedef struct{
    double x,z;   /* location */
    float  v;     /* value    */
}pt2d;


typedef struct{
    double x,y,z; /* location */
    float  v;     /* value    */
}pt3d;


void printpt2d(pt2d P);
/*< print point2d info  >*/


void printpt3d(pt3d P);
/*< print point3d info  >*/


void pt2dwrite1(sf_file F, 
		pt2d   *v, 
		size_t  n1, 
		int     k);
/*< output point2d 1-D vector >*/


void pt2dwrite2(sf_file F, 
		pt2d  **v, 
		size_t  n1, 
		size_t  n2,
		int     k);
/*< output point2d 2-D vector >*/


void pt3dwrite1(sf_file F, 
		pt3d   *v, 
		size_t  n1, 
		int     k);
/*< output point3d 1-D vector >*/


void pt3dwrite2(sf_file F, 
		pt3d  **v, 
		size_t  n1, 
		size_t  n2,
		int     k);
/*< output point3d 2-D vector >*/


void pt2dread1(sf_file F, 
	       pt2d   *v, 
	       size_t  n1, 
	       int     k);
/*< input point2d 1-D vector >*/


void pt2dread2(sf_file F, 
	       pt2d  **v, 
	       size_t  n1,
	       size_t  n2,
	       int     k);
/*< input point2d 2-D vector >*/


void pt3dread1(sf_file F, 
	       pt3d   *v, 
	       size_t  n1, 
	       int     k);
/*< input point3d 1-D vector >*/


void pt3dread2(sf_file F, 
	       pt3d  **v, 
	       size_t  n1, 
	       size_t  n2,
	       int     k);
/*< input point3d 2-D vector >*/


pt2d* pt2dalloc1( size_t n1);
/*< alloc point2d 1-D vector >*/


void pt2dfree1 (pt2d* tofree);
/*< free allocated storage >*/


pt2d** pt2dalloc2( size_t n1, size_t n2);
/*< alloc point2d 2-D vector >*/


pt2d*** pt2dalloc3( size_t n1,
		    size_t n2,
		    size_t n3);
/*< alloc point2d 3-D vector >*/


pt3d* pt3dalloc1( size_t n1);
/*< alloc point3d 1-D vector >*/


pt3d** pt3dalloc2( size_t n1,
		   size_t n2);
/*< alloc point3d 2-D vector >*/


pt3d*** pt3dalloc3( size_t n1,
		    size_t n2,
		    size_t n3);
/*< alloc point3d 3-D vector >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_polydiv_h
#define _sf_polydiv_h




void sf_polydiv_init( int nd       /* data size */, 
		      sf_filter bb /* filter */);
/*< initialize >*/


void sf_polydiv_lop( bool adj, bool add, 
		     int nx, int ny, float* xx, float*yy);
/*< linear operator >*/


void sf_polydiv_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_pqueue_h
#define _sf_pqueue_h


enum {SF_IN, SF_FRONT, SF_OUT};


void sf_pqueue_init (int n);
/*< Initialize heap with the maximum size >*/


void sf_pqueue_start (void);
/*< Set starting values >*/


void sf_pqueue_close (void);
/*< Free the allocated storage >*/


void sf_pqueue_insert (float* v);
/*< Insert an element (smallest first) >*/


void sf_pqueue_insert2 (float* v);
/*< Insert an element (largest first) >*/


float* sf_pqueue_extract (void);
/*< Extract the smallest element >*/


float* sf_pqueue_extract2 (void);
/*< Extract the largest element >*/


void sf_pqueue_update (float **v);
/*< restore the heap: the value has been altered >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_pweno_h
#define _sf_pweno_h




typedef struct Pweno *sf_pweno;
/* abstract data type */


typedef enum {FUNC1, DER1, BOTH1} derr;
/* flag values */


sf_pweno sf_pweno_init (int order /* interpolation order */,
              int n     /* data size */);
/*< Initialize interpolation object >*/


void sf_pweno_close (sf_pweno ent);
/*< Free internal storage >*/


float powerpeno (float x, float y, int p /* power order */);
/*< Limiter power-p eno >*/


void sf_pweno_set (sf_pweno ent, float* c /* data [n] */, int p /* power order */);
/*< Set the interpolation undivided difference table. c can be changed or freed afterwards >*/


void sf_pweno_apply (sf_pweno ent, 
		int i     /* grid location */, 
		float x   /* offset from grid */, 
		float *f  /* output data value */, 
		float *f1 /* output derivative */, 
		derr what /* flag of what to compute */);
/*< Apply interpolation >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_randn_h
#define _sf_randn_h


float sf_randn_one_bm (void);
/*< return a random number (normally distributed, Box-Muller method) >*/


void sf_randn (int nr, float *r /* [nr] */);
/*< fill an array with normally distributed numbers >*/


void sf_random (int nr, float *r /* [nr] */);
/*< fill an array with uniformly distributed numbers >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_recfilt_h
#define _sf_recfilt_h




void sf_recfilt_init( int nd    /* data size */, 
		   int nb    /* filter size */, 
		   float* bb /* filter [nb] */);
/*< initialize >*/


void sf_recfilt_lop( bool adj, bool add, int nx, int ny, float* xx, float*yy);
/*< linear operator >*/


void sf_recfilt_close (void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_repeat_h
#define _sf_repeat_h




void sf_repeat_init(int m1            /* trace length */, 
		 int m2            /* number of traces */, 
		 sf_operator oper1 /* operator */);
/*< initialize >*/


void sf_repeat_lop (bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< combined linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_runge_h
#define _sf_runge_h


void sf_runge_init(int dim1 /* dimensionality */, 
		   int n1   /* number of ray tracing steps */, 
		   float d1 /* step in time */);
/*< initialize >*/


void sf_runge_close(void);
/*< free allocated storage >*/


float sf_ode23 (float t /* time integration */,
		float* tol /* error tolerance */,
		float* y   /* [dim] solution */, 
		void* par  /* parameters for function evaluation */,
		void (*rhs)(void*,float*,float*) 
		/* RHS function */, 
		int (*term)(void*,float*)
	     /* function returning 1 if the ray needs to terminate */);
/*< ODE solver for dy/dt = f where f comes from rhs(par,y,f)
  Note: Value of y is changed inside the function.
  >*/


int sf_ode23_step (float* y    /* [dim] solution */, 
		   void* par   /* parameters for function evaluation */,
		   void (*rhs)(void*,float*,float*) 
		   /* RHS function */, 
		   int (*term)(void*,float*)
		   /* function returning 1 if the ray needs to terminate */, 
		   float** traj /* [nt+1][dim] - ray trajectory (output) */);
/*< ODE solver for dy/dt = f where f comes from rhs(par,y,f)
  Note:
  1. Value of y is changed inside the function.
  2. The output code for it = ode23_step(...)
  it=0 - ray traced to the end without termination
  it>0 - ray terminated
  The total traveltime along the ray is 
  nt*dt if (it = 0); it*dt otherwise 
  >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_quantile_h
#define _sf_quantile_h


float sf_quantile(int q    /* quantile */, 
		  int n    /* array length */, 
		  float* a /* array [n] */);
/*< find quantile (caution: a is changed) >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_quadratic_h
#define _sf_quadratic_h


float sf_quadratic_solve (float a, float b, float c);
/*< solves a x^2 + 2 b x + c == 0 for smallest positive x >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_sharpen_h
#define _sf_sharpen_h


void sf_sharpen_init(int n1     /* data size */,
		     float perc /* quantile percentage */,
		     float fact /* multiplicative factor */);
/*< initialize >*/


void sf_sharpen_close(void);
/*< free allocated storage >*/


float sf_sharpen(const float *pp);
/*< compute weight for sharpening regularization >*/


void sf_csharpen(const sf_complex *pp);
/*< compute weight for sharpening regularization >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_sharpinv_h
#define _sf_sharpinv_h


void sf_csharpinv(sf_coperator oper /* inverted operator */, 
		  float scale       /* extra operator scaling */,
		  int niter         /* number of outer iterations */,
		  int ncycle        /* number of iterations */,
		  float perc        /* sharpening percentage */,
		  bool verb         /* verbosity flag */,
		  int nq, int np    /* model and data size */,
		  sf_complex *qq    /* model */, 
		  sf_complex *pp    /* data */,
		  bool twhole       /* thresholding flag */);
/*< sharp inversion for complex-valued operators >*/


void sf_sharpinv(sf_operator oper  /* inverted operator */, 
		 float scale       /* extra operator scaling */,
		 int niter         /* number of outer iterations */,
		 int ncycle        /* number of iterations */,
		 float perc        /* sharpening percentage */,
		 bool verb         /* verbosity flag */,
		 int nq, int np    /* model and data size */,
		 float *qq         /* model */, 
		 float *pp         /* data */,
                 bool twhole       /* thresholding flag */);
/*< sharp inversion for real-valued operators >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_slice_h
#define _sf_slice_h




typedef struct sf_Slice *sf_slice;
/* abstract data type */


typedef struct sf_FSlice *sf_fslice;
/* abstract data type */


sf_slice sf_slice_init(sf_file file, int n1, int n2, int n3);
/*< initialize a sliceable file object >*/


/*------------------------------------------------------------*/
void sf_slice_get(sf_slice sl, int i3, float* data);
/*< get a slice at level i3 >*/


/*------------------------------------------------------------*/
void sf_slice_put(sf_slice sl, int i3, float* data);
/*< put a slice at level i3 >*/


/*------------------------------------------------------------*/
void sf_cslice_get(sf_slice sl, int i3, sf_complex* data);
/*< get a slice at level i3 >*/


/*------------------------------------------------------------*/
void sf_cslice_put(sf_slice sl, int i3, sf_complex* data);
/*< put a slice at level i3 >*/


/*------------------------------------------------------------*/
sf_fslice sf_fslice_init(int n1, int n2, size_t size);
/*< initialize a sliceable file object >*/


/*------------------------------------------------------------*/
void sf_fslice_get(sf_fslice sl, int i2, void* data);
/*< get a slice at level i2 >*/


/*------------------------------------------------------------*/
void sf_fslice_put(sf_fslice sl, int i2, void* data);
/*< put a slice at level i2 >*/


/*------------------------------------------------------------*/
void sf_fslice_close(sf_fslice sl);
/*< remove the file and free allocated storage >*/


/*------------------------------------------------------------*/
void sf_fslice_load(sf_file in, sf_fslice sl, sf_datatype type);
/*< load the contents of in into a slice file >*/


/*------------------------------------------------------------*/
void sf_fslice_dump(sf_file out, sf_fslice sl, sf_datatype type);
/*< dump the contents of a slice file to out >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_smooth1_h
#define _sf_smooth1_h


void sf_smooth1_init(int n1, int n2     /* data size */,
		  int nc1            /* number of components */,
		  int nb1, int nb2   /* smoothing radius */);
/*< initialize >*/


void sf_smooth1_close (void);
/*< free allocated storage >*/


void sf_smooth1_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< smooth each component >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_tridiagonal_h
#define _sf_tridiagonal_h




typedef struct sf_Tris *sf_tris;
/* abstract data type */


sf_tris sf_tridiagonal_init (int n /* matrix size */);
/*< initialize >*/


void sf_tridiagonal_define (sf_tris slv /* solver object */, 
			    float* diag /* diagonal */, 
			    float* offd /* off-diagonal */);
/*< fill the matrix >*/


void sf_tridiagonal_const_define (sf_tris slv /* solver object */, 
				  float diag  /* diagonal */, 
				  float offd  /* off-diagonal */,
				  bool damp   /* damping */);
/*< fill the matrix for the Toeplitz case >*/


void sf_tridiagonal_solve (sf_tris slv /* solver object */, 
			   float* b /* in - right-hand side, out - solution */);
/*< invert the matrix >*/


void sf_tridiagonal_close (sf_tris slv);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_spline_h
#define _sf_spline_h




sf_bands sf_spline_init (int nw /* interpolator length */, 
			 int nd /* data length */);
/*< initialize a banded matrix >*/


sf_tris sf_spline4_init (int nd /* data length */);
/*< initialize a tridiagonal matrix for cubic splines >*/


void sf_spline4_post (int n            /* total trace length */, 
		      int n1           /* start point */, 
		      int n2           /* end point */, 
		      const float* inp /* spline coefficients */, 
		      float* out       /* function values */);
/*< cubic spline post-filtering >*/


void sf_spline_post (int nw, int o, int d, int n, 
		     const float *modl, float *datr);
/*< post-filtering to convert spline coefficients to model >*/


void sf_spline2 (sf_bands slv1, sf_bands slv2, 
		 int n1, int n2, float** dat, float* tmp);
/*< 2-D spline pre-filtering >*/


void sf_spline3 (sf_bands slv1, sf_bands slv2, sf_bands slv3, 
		 int n1, int n2, int n3, float*** dat, float* tmp2, float* tmp3);
/*< 3-D spline pre-filtering >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_stack_h
#define _sf_stack_h




typedef struct sf_Stack *sf_stack;


sf_stack sf_stack_init (size_t size);
/*< create a stack >*/


void sf_stack_print (sf_stack s);
/*< print out a stack (for debugging) >*/


int sf_stack_get (sf_stack s);
/*< extract stack length >*/


void sf_stack_set (sf_stack s, int pos);
/*< set stack position >*/


void sf_push(sf_stack s, void *data, int type);
/*< push data into stack (requires unique data for each push) >*/


void* sf_pop(sf_stack s);
/*< pop data from stack >*/


bool sf_full (sf_stack s);
/*< test if the stack is full >*/


int sf_top(sf_stack s);
/*< return the top type >*/


void sf_stack_close(sf_stack s);
/*< free allocated memory >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_stretch_h
#define _sf_stretch_h




typedef struct sf_Map *sf_map;
/* abstract data type */


sf_map sf_stretch_init (int n1, float o1, float d1 /* regular axis */, 
			int nd                     /* data length */, 
			float eps                  /* regularization */, 
			bool narrow                /* if zero boundary */);
/*< initialize >*/


void sf_stretch_define (sf_map str, const float* coord);
/*< define coordinates >*/


void sf_stretch_apply (sf_map str, const float* ord, float* mod);
/*< convert ordinates to model >*/


void sf_stretch_invert (sf_map str, float* ord, const float* mod);
/*< convert model to ordinates by linear interpolation >*/


void sf_stretch_close (sf_map str);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_stretch4_h
#define _sf_stretch4_h




typedef struct sf_Map4 *sf_map4;
/* abstract data type */


sf_map4 sf_stretch4_init (int n1, float o1, float d1 /* regular axis */, 
		    int nd                     /* data samples */, 
		    float eps                  /* regularization */);
/*< initialize >*/


void sf_stretch4_define (sf_map4 str,
			 const float* coord /* [nd] */,
			 bool der /* derivative flag */);
/*< set coordinates >*/


void sf_cstretch4_apply (sf_map4 str, 
		      const sf_complex* ord /* [nd] */, 
		      sf_complex* mod       /* [n1] */);
/*< complex transform ordinates to model >*/


void sf_stretch4_apply_adj (bool add,  /* add flag */
			    sf_map4 str, 
			    float* ord /* [nd] */, 
			    float* mod /* [n1] */);
/*< transform model to ordinates by adjoint operation >*/


void sf_stretch4_apply (bool add /* add flag */,
		     sf_map4 str, 
		     float* ord /* [nd] */, 
		     float* mod /* [n1] */);
/*< transform ordinates to model >*/


void sf_cstretch4_invert (sf_map4 str, 
		       sf_complex* ord       /* [nd] */, 
		       const sf_complex* mod /* [n1] */);
/*< convert model to ordinates by spline interpolation >*/


void sf_stretch4_invert (bool add /* add flag */,
			 sf_map4 str, 
			 float* ord /* [nd] */, 
			 float* mod /* [n1] */);
/*< convert model to ordinates by spline interpolation >*/


void sf_stretch4_invert_adj (bool add /* add flag */,
			     sf_map4 str, 
			     float* ord /* [nd] */, 
			     float* mod       /* [n1] */);
/*< convert ordinates to model by adjoint spline interpolation >*/


void sf_stretch4_close (sf_map4 str);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_system_h
#define _sf_system_h


void sf_system(const char *command);
/*< System command >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_tent2_h
#define _sf_tent2_h


void sf_tent2 (int dim          /* number of dimensions */, 
	       const int* nwind /* window size [dim] */, 
	       float* windwt    /* window weight */);
/*< define window weight >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_timer_h
#define _sf_timer_h




typedef struct ExecTimer *sf_timer;
/* abstract data type */


sf_timer sf_timer_init (void);
/*< Initialize timer object. >*/


void sf_timer_close (sf_timer timer);
/*< Destroy timer object. >*/


void sf_timer_start (sf_timer timer);
/*< Start time measurement session. >*/


void sf_timer_stop (sf_timer timer);
/*< Stop time measurement session. >*/


void sf_timer_reset (sf_timer timer);
/*< Reset the timer to 0. Does not change the timer running state. >*/


float sf_timer_get_total_time (sf_timer timer);
/*< Total time in msec for all sessions. after start. >*/


float sf_timer_get_diff_time (sf_timer timer);
/*< Time in msec for the last session. >*/


float sf_timer_get_average_time (sf_timer timer);
/*< Average time in msec. for all runs. >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_tinysolver_h
#define _sf_tinysolver_h


void sf_tinysolver (sf_operator Fop       /* linear operator */, 
		    sf_solverstep stepper /* stepping function */, 
		    int nm                /* size of model */, 
		    int nd                /* size of data */, 
		    float* m              /* estimated model */,
		    const float* m0       /* starting model */,
		    const float* d        /* data */, 
		    int niter             /* iterations */);
/*< Generic linear solver. Solves oper{x} =~ dat >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_triangle_h
#define _sf_triangle_h




typedef struct sf_Triangle *sf_triangle;
/* abstract data type */


sf_triangle sf_triangle_init (int  nbox /* triangle length */, 
			      int  ndat /* data length */,
                              bool box  /* if box instead of triangle */);
/*< initialize >*/


void sf_smooth (sf_triangle tr  /* smoothing object */, 
		int o, int d    /* trace sampling */, 
		bool der        /* if derivative */, 
		float *x        /* data (smoothed in place) */);
/*< apply triangle smoothing >*/


void sf_dsmooth (sf_triangle tr  /* smoothing object */, 
		int o, int d    /* trace sampling */, 
		bool der        /* if derivative */, 
		float *x        /* data (smoothed in place) */);
/*< apply triangle smoothing >*/


void sf_smooth2 (sf_triangle tr  /* smoothing object */, 
		 int o, int d    /* trace sampling */, 
		 bool der        /* if derivative */,
		 float *x        /* data (smoothed in place) */);
/*< apply adjoint triangle smoothing >*/


void sf_dsmooth2 (sf_triangle tr  /* smoothing object */, 
		 int o, int d    /* trace sampling */, 
		 bool der        /* if derivative */,
		 float *x        /* data (smoothed in place) */);
/*< apply adjoint triangle smoothing >*/


void  sf_triangle_close(sf_triangle tr);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_triangle1_h
#define _sf_triangle1_h




void sf_triangle1_init (int nbox /* triangle size */, 
			int ndat /* data size */);
/*< initialize >*/


void sf_triangle1_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/


void sf_triangle1_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_triangle2_h
#define _sf_triangle2_h




void sf_triangle2_init (int nbox1, int nbox2 /* triangle size */, 
			int ndat1, int ndat2 /* data size */,
			int nrep /* repeat smoothing */);
/*< initialize >*/


void sf_triangle2_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/


void sf_triangle2_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_trianglen_h
#define _sf_trianglen_h




void sf_trianglen_init (int ndim  /* number of dimensions */, 
			int *nbox /* triangle radius [ndim] */, 
			int *ndat /* data dimensions [ndim] */);
/*< initialize >*/


void sf_trianglen_lop (bool adj, bool add, int nx, int ny, float* x, float* y);
/*< linear operator >*/


void sf_trianglen_close(void);
/*< free allocated storage >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_upgrad_h
#define _sf_upgrad_h


typedef struct Sf_Upgrad *sf_upgrad;
/* abstract data type */


sf_upgrad sf_upgrad_init(int mdim        /* number of dimensions */,
			 const int *mm   /* [dim] data size */,
			 const float *d  /* [dim] data sampling */);
/*< initialize >*/


void sf_upgrad_set(sf_upgrad upg, const float *r0 /* reference */);
/*< supply reference >*/


void sf_upgrad_close(sf_upgrad upg);
/*< free allocated storage >*/


void sf_upgrad_solve(sf_upgrad upg,
		     const float *rhs /* right-hand side */, 
		     float *x         /* solution */,
		     const float *x0  /* initial solution */);
/*< inverse operator >*/


void sf_upgrad_inverse(sf_upgrad upg,
		       float *rhs       /* right-hand side */,
		       const float *x   /* solution */,
		       const float *x0  /* initial solution */);
/*< adjoint of inverse operator >*/


void sf_upgrad_forw(sf_upgrad upg,
		    const float *x /* solution */,
		    float *rhs     /* right-hand side */);
/*< forward operator >*/


void sf_upgrad_grad(sf_upgrad upg,
		    const float *x /* input */,
		    float **grad   /* gradient */);
/*< forward operator >*/


void sf_upgrad_adj(sf_upgrad upg,
		   float *x         /* solution */,
		   const float *rhs /* right-hand side */);
/*< adjoint operator >*/


void sf_upgrad_grad_adj(sf_upgrad upg,
			float *x     /* output */,
			float **grad /* gradient */);
/*< adjoint gradient operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_vector_h
#define _sf_vector_h








typedef struct{
    double dx,dz;
}vc2d;


typedef struct{
    double dx,dy,dz;
}vc3d;


/*------------------------------------------------------------*/
double det3(double *m);
/*< compute 3D determinant >*/


/*------------------------------------------------------------*/
double det2(double *m);
/*< compute 2D determinant >*/


/*------------------------------------------------------------*/
double jac3d(pt3d *C, pt3d *T, pt3d *P, pt3d *Q);
/*< 3D jacobian >*/


/*------------------------------------------------------------*/
vc3d vec3d(pt3d* O, pt3d* A);
/*< build 3D vector >*/


vc2d vec2d(pt2d* O, pt2d* A);
/*< build 2D vector >*/


/*------------------------------------------------------------*/
vc3d axa3d( int n);
/*< build 3D unit vector >*/


/*------------------------------------------------------------*/
double scp3d(vc3d* U, vc3d* V);
/*< scalar product of 3D vectors >*/


double scp2d(vc2d* U, vc2d* V);
/*< scalar product of 2D vectors >*/


/*------------------------------------------------------------*/
vc3d vcp3d(vc3d* U, vc3d* V);
/*< vector product of 3D vectors >*/


/*------------------------------------------------------------*/
double len3d(vc3d* V);
/*< 3D vector length >*/


double len2d(vc2d* V);
/*< 2D vector length >*/


/*------------------------------------------------------------*/
vc3d nor3d(vc3d* V);
/*< normalize 3D vector >*/


vc2d nor2d(vc2d* V);
/*< normalize 2D vector >*/


/*------------------------------------------------------------*/
double ang3d(vc3d* U, vc3d* V);
/*< angle between 3D vectors >*/


double ang2d(vc2d* U, vc2d* V);
/*< angle between 2D vectors >*/


/*------------------------------------------------------------*/
pt3d tip3d(pt3d* O, vc3d* V);
/*< tip of a 3D vector >*/


pt2d tip2d(pt2d* O, vc2d* V);
/*< tip of a 3D vector >*/


/*------------------------------------------------------------*/
vc3d scl3d(vc3d* V, float s);
/*< scale a 3D vector >*/


vc2d scl2d(vc2d* V, float s);
/*< scale a 2D vector >*/


/*------------------------------------------------------------*/
vc3d rot3d(vc3d *nn,
	   vc3d *aa,
	   float phi);
/*< rotate a 3D vector >*/


void vc2dread1(sf_file F,
               vc2d   *v,
               size_t  n1);
/*< input vector2d 1-D vector >*/


void vc3dread1(sf_file F,
               vc3d   *v,
               size_t  n1);
/*< input vector3d 1-D vector >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_wavelet_h
#define _sf_wavelet_h


void sf_wavelet_init(int n /* data size */, bool inv1, bool unit1, char type);
/*< allocate space >*/


void sf_wavelet_close(void);
/*< deallocate space >*/


void sf_wavelet_lop(bool adj, bool add, int nx, int ny, float *x, float *y);
/*< linear operator >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_weight_h
#define _sf_weight_h


void sf_weight_init(float *w1);
/*< initialize >*/


void sf_weight_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/


void sf_cweight_lop (bool adj, bool add, int nx, int ny, 
		     sf_complex* xx, sf_complex* yy);
/*< linear operator >*/


void sf_weight_apply(int nx, float *xx);
/*< apply weighting in place >*/


void sf_cweight_apply(int nx, sf_complex *xx);
/*< apply weighting in place >*/

#endif
/* This file is automatically generated. DO NOT EDIT! */

#ifndef _sf_weight2_h
#define _sf_weight2_h




void sf_weight2_init(int nw1   /* number of components */, 
		     int n     /* model size */, 
		     float *ww /* weight [nw*n] */);
/*< initialize >*/


void sf_weight2_close(void);
/*< free allocated storage >*/


void sf_weight2_lop (bool adj, bool add, int nx, int ny, float* xx, float* yy);
/*< linear operator >*/

#endif
#ifndef KISS_FTR_H
#define KISS_FTR_H

#ifdef __cplusplus
extern "C" {
#endif

    
/* 
 
 Real optimized version can save about 45% cpu time vs. complex fft of a real seq.

 
 
 */

typedef struct kiss_fftr_state *kiss_fftr_cfg;


kiss_fftr_cfg kiss_fftr_alloc(int nfft,int inverse_fft,void * mem, size_t * lenmem);
/*
 nfft must be even

 If you don't care to allocate space, use mem = lenmem = NULL 
*/


void kiss_fftr(kiss_fftr_cfg cfg,const kiss_fft_scalar *timedata,kiss_fft_cpx *freqdata);
/*
 input timedata has nfft scalar points
 output freqdata has nfft/2+1 complex points
*/

void kiss_fftri(kiss_fftr_cfg cfg,const kiss_fft_cpx *freqdata,kiss_fft_scalar *timedata);
/*
 input freqdata has  nfft/2+1 complex points
 output timedata has nfft scalar points
*/

#define kiss_fftr_free free

#ifdef __cplusplus
}
#endif
#endif
/* 
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)  
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.
   Copyright (C) 2005, Mutsuo Saito
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote 
        products derived from this software without specific prior written 
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/


                                                                                                                                 
#ifdef __cplusplus
extern "C" {
#endif


/* initializes mt[N] with a seed */
void init_genrand(unsigned long s);

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long init_key[], int key_length);

/* generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void);

/* generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(void);

/* These real versions are due to Isaku Wada, 2002/01/09 added */
/* generates a random number on [0,1]-real-interval */
double genrand_real1(void);

/* generates a random number on [0,1)-real-interval */
double genrand_real2(void);

/* generates a random number on (0,1)-real-interval */
double genrand_real3(void);

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(void);

                                                                                                                       
#ifdef __cplusplus
}
#endif


#ifndef _sf_fblas_h_
#define _sf_fblas_h_


#ifndef cpx8
#define cpx8 sf_complex
#endif

#ifndef cpx16
#define cpx16 sf_double_complex
#endif
  
double sasum_(int *n,float *x,int *incx);
int  saxpy_(int *n,float *alpha,float *x,int *incx,float *y,int *incy);
void  saxpyi_(int *nz,float *a,float *x,int *indx,float *y);
double scasum_(int *n,void *x,int *incx); 
double scnrm2_(int *n,void *x,int *incx); 
int  scopy_(int *n,float *x,int *incx,float *y,int *incy);
double sdot_(int *n,float *x,int *incx,float *y,int *incy);
float sdoti_(int *nz,float *x,int *indx,float *y);
void  sgthr_(int *nz,float *y,float *x,int *indx);
void  sgthrz_(int *nz,float *y,float *x,int *indx);
double snrm2_(int *n,float *x,int *incx);
int  srot_(int *n,float *x,int *incx,float *y,int *incy,float *c,float *s);
int  srotg_(float *a,float *b,float *c,float *s);
void  sroti_(int *nz,float *x,int *indx,float *y,float *c,float *s);
int  srotm_(int *n,float *x,int *incx,float *y,int *incy,float *param);
int  srotmg_(float *d1,float *d2,float *x1,float *y1,float *param);
int  sscal_(int *n,float *a,float *x,int *incx);
void  ssctr_(int *nz,float *x,int *indx,float *y);
int  sswap_(int *n,float *x,int *incx,float *y,int *incy);
int   isamax_(int *n,float *x,int *incx);
int   isamin_(int *n,float *x,int *incx);
  
int caxpy_(int *n,void *alpha,void *x,int *incx,void *y,int *incy); 
void caxpyi_(int *nz,cpx8 *a,cpx8 *x,int *indx,cpx8 *y); 
int ccopy_(int *n,void *x,int *incx,void *y,int *incy); 
void cdotc_(void *pres,int *n,void *x,int *incx,void *y,int *incy); 
void cdotci_(cpx8 *pres,int *nz,cpx8 *x,int *indx,cpx8 *y); 
void cdotu_(void *pres,int *n,void *x,int *incx,void *y,int *incy); 
void cdotui_(cpx8 *pres,int *nz,cpx8 *x,int *indx,cpx8 *y); 
void cgthr_(int *nz,cpx8 *y,cpx8 *x,int *indx); 
void cgthrz_(int *nz,cpx8 *y,cpx8 *x,int *indx); 
int crotg_(void *a,void *b,float *c,void *s); 
int cscal_(int *n,void *a,void *x,int *incx); 
void csctr_(int *nz,cpx8 *x,int *indx,cpx8 *y); 
int csrot_(int *n,void *x,int *incx,void *y,int *incy,float *c,float *s); 
int csscal_(int *n,float *a,void *x,int *incx); 
int cswap_(int *n,void *x,int *incx,void *y,int *incy); 
int  icamax_(int *n,void *x,int *incx); 
int  icamin_(int *n,cpx8 *x,int *incx); 
  
double dasum_(int *n,double *x,int *incx);
int   daxpy_(int *n,double *alpha,double *x,int *incx,double *y,int *incy);
void   daxpyi_(int *nz,double *a,double *x,int *indx,double *y);
int   dcopy_(int *n,double *x,int *incx,double *y,int *incy);
double ddot_(int *n,double *x,int *incx,double *y,int *incy);
double ddoti_(int *nz,double *x,int *indx,double *y);
void   dgthr_(int *nz,double *y,double *x,int *indx);
void   dgthrz_(int *nz,double *y,double *x,int *indx);
double dnrm2_(int *n,double *x,int *incx);
int   drot_(int *n,double *x,int *incx,double *y,int *incy,double *c,double *s);
int   drotg_(double *a,double *b,double *c,double *s);
void   droti_(int *nz,double *x,int *indx,double *y,double *c,double *s);
int   drotm_(int *n,double *x,int *incx,double *y,int *incy,double *param);
int   drotmg_(double *d1,double *d2,double *x1,double *y1,double *param);
int   dscal_(int *n,double *a,double *x,int *incx);
void   dsctr_(int *nz,double *x,int *indx,double *y);
int   dswap_(int *n,double *x,int *incx,double *y,int *incy);
double dzasum_(int *n,void *x,int *incx); 
double dznrm2_(int *n,void *x,int *incx); 
int    idamax_(int *n,double *x,int *incx);
int    idamin_(int *n,double *x,int *incx);
  
int zaxpy_(int *n,void *alpha,void *x,int *incx,void *y,int *incy); 
void zaxpyi_(int *nz,cpx16 *a,cpx16 *x,int *indx,cpx16 *y); 
int zcopy_(int *n,void *x,int *incx,void *y,int *incy); 
void zdotc_(void *pres,int *n,void *x,int *incx,void *y,int *incy); 
void zdotci_(cpx16 *pres,int *nz,cpx16 *x,int *indx,cpx16 *y); 
void zdotu_(void *pres,int *n,void *x,int *incx,void *y,int *incy); 
void zdotui_(cpx16 *pres,int *nz,cpx16 *x,int *indx,cpx16 *y); 
int zdrot_(int *n,void *x,int *incx,void *y,int *incy,double *c,double *s); 
int zdscal_(int *n,double *a,void *x,int *incx); 
void zgthr_(int *nz,cpx16 *y,cpx16 *x,int *indx); 
void zgthrz_(int *nz,cpx16 *y,cpx16 *x,int *indx); 
int zrotg_(void *a,void *b,double *c,void *s); 
int zscal_(int *n,void *a,void *x,int *incx); 
void zsctr_(int *nz,cpx16 *x,int *indx,cpx16 *y); 
int zswap_(int *n,void *x,int *incx,void *y,int *incy); 
int  izamax_(int *n,void *x,int *incx); 
int  izamin_(int *n,cpx16 *x,int *incx); 
  
/* blas level2 */
  
int sgbmv_(char *trans,int *m,int *n,int *kl,int *ku,float *alpha,float *a,int *lda,float *x,int *incx,float *beta,float *y,int *incy);
int sgemv_(char *trans,int *m,int *n,float *alpha,float *a,int *lda,float *x,int *incx,float *beta,float *y,int *incy);
int sger_(int *m,int *n,float *alpha,float *x,int *incx,float *y,int *incy,float *a,int *lda);
int ssbmv_(char *uplo,int *n,int *k,float *alpha,float *a,int *lda,float *x,int *incx,float *beta,float *y,int *incy);
int sspmv_(char *uplo,int *n,float *alpha,float *ap,float *x,int *incx,float *beta,float *y,int *incy);
int sspr_(char *uplo,int *n,float *alpha,float *x,int *incx,float *ap);
int sspr2_(char *uplo,int *n,float *alpha,float *x,int *incx,float *y,int *incy,float *ap);
int ssymv_(char *uplo,int *n,float *alpha,float *a,int *lda,float *x,int *incx,float *beta,float *y,int *incy);
int ssyr_(char *uplo,int *n,float *alpha,float *x,int *incx,float *a,int *lda);
int ssyr2_(char *uplo,int *n,float *alpha,float *x,int *incx,float *y,int *incy,float *a,int *lda);
int stbmv_(char *uplo,char *trans,char *diag,int *n,int *k,float *a,int *lda,float *x,int *incx);
int stbsv_(char *uplo,char *trans,char *diag,int *n,int *k,float *a,int *lda,float *x,int *incx);
int stpmv_(char *uplo,char *trans,char *diag,int *n,float *ap,float *x,int *incx);
int stpsv_(char *uplo,char *trans,char *diag,int *n,float *ap,float *x,int *incx);
int strmv_(char *uplo,char *transa,char *diag,int *n,float *a,int *lda,float *b,int *incx);
int strsv_(char *uplo,char *trans,char *diag,int *n,float *a,int *lda,float *x,int *incx);
  
int cgbmv_(char *trans,int *m,int *n,int *kl,int *ku,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int cgemv_(char *trans,int *m,int *n,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int cgerc_(int *m,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *a,int *lda); 
int cgeru_(int *m,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *a,int *lda); 
int chbmv_(char *uplo,int *n,int *k,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int chemv_(char *uplo,int *n,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int cher_(char *uplo,int *n,float *alpha,void *x,int *incx,void *a,int *lda); 
int cher2_(char *uplo,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *a,int *lda); 
int chpmv_(char *uplo,int *n,void *alpha,void *ap,void *x,int *incx,void *beta,void *y,int *incy); 
int chpr_(char *uplo,int *n,float *alpha,void *x,int *incx,void *ap); 
int chpr2_(char *uplo,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *ap); 
int ctbmv_(char *uplo,char *trans,char *diag,int *n,int *k,void *a,int *lda,void *x,int *incx); 
int ctbsv_(char *uplo,char *trans,char *diag,int *n,int *k,void *a,int *lda,void *x,int *incx); 
int ctpmv_(char *uplo,char *trans,char *diag,int *n,void *ap,void *x,int *incx); 
int ctpsv_(char *uplo,char *trans,char *diag,int *n,void *ap,void *x,int *incx); 
int ctrmv_(char *uplo,char *transa,char *diag,int *n,void *a,int *lda,void *b,int *incx); 
int ctrsv_(char *uplo,char *trans,char *diag,int *n,void *a,int *lda,void *x,int *incx); 
  
int dgbmv_(char *trans,int *m,int *n,int *kl,int *ku,double *alpha,double *a,int *lda,double *x,int *incx,double *beta,double *y,int *incy);
int dgemv_(char *trans,int *m,int *n,double *alpha,double *a,int *lda,double *x,int *incx,double *beta,double *y,int *incy);
int dger_(int *m,int *n,double *alpha,double *x,int *incx,double *y,int *incy,double *a,int *lda);
int dsbmv_(char *uplo,int *n,int *k,double *alpha,double *a,int *lda,double *x,int *incx,double *beta,double *y,int *incy);
int dspmv_(char *uplo,int *n,double *alpha,double *ap,double *x,int *incx,double *beta,double *y,int *incy);
int dspr_(char *uplo,int *n,double *alpha,double *x,int *incx,double *ap);
int dspr2_(char *uplo,int *n,double *alpha,double *x,int *incx,double *y,int *incy,double *ap);
int dsymv_(char *uplo,int *n,double *alpha,double *a,int *lda,double *x,int *incx,double *beta,double *y,int *incy);
int dsyr_(char *uplo,int *n,double *alpha,double *x,int *incx,double *a,int *lda);
int dsyr2_(char *uplo,int *n,double *alpha,double *x,int *incx,double *y,int *incy,double *a,int *lda);
int dtbmv_(char *uplo,char *trans,char *diag,int *n,int *k,double *a,int *lda,double *x,int *incx);
int dtbsv_(char *uplo,char *trans,char *diag,int *n,int *k,double *a,int *lda,double *x,int *incx);
int dtpmv_(char *uplo,char *trans,char *diag,int *n,double *ap,double *x,int *incx);
int dtpsv_(char *uplo,char *trans,char *diag,int *n,double *ap,double *x,int *incx);
int dtrmv_(char *uplo,char *transa,char *diag,int *n,double *a,int *lda,double *b,int *incx);
int dtrsv_(char *uplo,char *trans,char *diag,int *n,double *a,int *lda,double *x,int *incx);
  
int zgbmv_(char *trans,int *m,int *n,int *kl,int *ku,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int zgemv_(char *trans,int *m,int *n,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int zgerc_(int *m,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *a,int *lda); 
int zgeru_(int *m,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *a,int *lda); 
int zhbmv_(char *uplo,int *n,int *k,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int zhemv_(char *uplo,int *n,void *alpha,void *a,int *lda,void *x,int *incx,void *beta,void *y,int *incy); 
int zher_(char *uplo,int *n,double *alpha,void *x,int *incx,void *a,int *lda); 
int zher2_(char *uplo,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *a,int *lda); 
int zhpmv_(char *uplo,int *n,void *alpha,void *ap,void *x,int *incx,void *beta,void *y,int *incy); 
int zhpr_(char *uplo,int *n,double *alpha,void *x,int *incx,void *ap); 
int zhpr2_(char *uplo,int *n,void *alpha,void *x,int *incx,void *y,int *incy,void *ap); 
int ztbmv_(char *uplo,char *trans,char *diag,int *n,int *k,void *a,int *lda,void *x,int *incx); 
int ztbsv_(char *uplo,char *trans,char *diag,int *n,int *k,void *a,int *lda,void *x,int *incx); 
int ztpmv_(char *uplo,char *trans,char *diag,int *n,void *ap,void *x,int *incx); 
int ztpsv_(char *uplo,char *trans,char *diag,int *n,void *ap,void *x,int *incx); 
int ztrmv_(char *uplo,char *transa,char *diag,int *n,void *a,int *lda,void *b,int *incx); 
int ztrsv_(char *uplo,char *trans,char *diag,int *n,void *a,int *lda,void *x,int *incx); 
  
/* blas level3 */
  
int sgemm_(char *transa,char *transb,int *m,int *n,int *k,float *alpha,float *a,int *lda,float *b,int *ldb,float *beta,float *c,int *ldc);
int ssymm_(char *side,char *uplo,int *m,int *n,float *alpha,float *a,int *lda,float *b,int *ldb,float *beta,float *c,int *ldc);
int ssyr2k_(char *uplo,char *trans,int *n,int *k,float *alpha,float *a,int *lda,float *b,int *ldb,float *beta,float *c,int *ldc);
int ssyrk_(char *uplo,char *trans,int *n,int *k,float *alpha,float *a,int *lda,float *beta,float *c,int *ldc);
int strmm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,float *alpha,float *a,int *lda,float *b,int *ldb);
int strsm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,float *alpha,float *a,int *lda,float *b,int *ldb);
  
int cgemm_(char *transa,char *transb,int *m,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int chemm_(char *side,char *uplo,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int cher2k_(char *uplo,char *trans,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,float *beta,void *c,int *ldc); 
int cherk_(char *uplo,char *trans,int *n,int *k,float *alpha,void *a,int *lda,float *beta,void *c,int *ldc); 
int csymm_(char *side,char *uplo,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int csyr2k_(char *uplo,char *trans,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int csyrk_(char *uplo,char *trans,int *n,int *k,void *alpha,void *a,int *lda,void *beta,void *c,int *ldc); 
int ctrmm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb); 
int ctrsm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb); 
  
int dgemm_(char *transa,char *transb,int *m,int *n,int *k,double *alpha,double *a,int *lda,double *b,int *ldb,double *beta,double *c,int *ldc);
int dsymm_(char *side,char *uplo,int *m,int *n,double *alpha,double *a,int *lda,double *b,int *ldb,double *beta,double *c,int *ldc);
int dsyr2k_(char *uplo,char *trans,int *n,int *k,double *alpha,double *a,int *lda,double *b,int *ldb,double *beta,double *c,int *ldc);
int dsyrk_(char *uplo,char *trans,int *n,int *k,double *alpha,double *a,int *lda,double *beta,double *c,int *ldc);
int dtrmm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,double *alpha,double *a,int *lda,double *b,int *ldb);
int dtrsm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,double *alpha,double *a,int *lda,double *b,int *ldb);
  
int zgemm_(char *transa,char *transb,int *m,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int zgemm_(char *transa,char *transb,int *m,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int zhemm_(char *side,char *uplo,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int zher2k_(char *uplo,char *trans,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,double *beta,void *c,int *ldc); 
int zherk_(char *uplo,char *trans,int *n,int *k,double *alpha,void *a,int *lda,double *beta,void *c,int *ldc); 
int zsymm_(char *side,char *uplo,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int zsyr2k_(char *uplo,char *trans,int *n,int *k,void *alpha,void *a,int *lda,void *b,int *ldb,void *beta,void *c,int *ldc); 
int zsyrk_(char *uplo,char *trans,int *n,int *k,void *alpha,void *a,int *lda,void *beta,void *c,int *ldc); 
int ztrmm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb); 
int ztrsm_(char *side,char *uplo,char *transa,char *diag,int *m,int *n,void *alpha,void *a,int *lda,void *b,int *ldb); 


#endif

#ifndef _sf_lapack_h_
#define _sf_lapack_h_

#ifdef __APPLE__

/* #define __VECLIB__ */

#include <Accelerate/Accelerate.h>

/* #include <vecLib/clapack.h> */

#define MKL_Complex8 __CLPK_complex 
#define MKL_Complex16 __CLPK_doublecomplex 

#else

#ifdef HAVE_MKL

#include <mkl.h>

#else

#define MKL_Complex8 cpx8
#define MKL_Complex16 cpx16

void cbdsqr_(char *uplo, int *n, int *ncvt, int *nru, int *ncc, float *d, float *e, cpx8 *vt, int *ldvt, cpx8 *u, int *ldu, cpx8 *c, int *ldc, float *rwork, int *info);
void cgbbrd_(char *vect, int *m, int *n, int *ncc, int *kl, int *ku, cpx8 *ab, int *ldab, float *d, float *e, cpx8 *q, int *ldq, cpx8 *pt, int *ldpt, cpx8 *c, int *ldc, cpx8 *work, float *rwork, int *info);
void cgbcon_(char *norm, int *n, int *kl, int *ku, cpx8 *ab, int *ldab, int *ipiv, float *anorm, float *rcond, cpx8 *work, float *rwork, int *info);
void cgbequ_(int *m, int *n, int *kl, int *ku, cpx8 *ab, int *ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);
void cgbrfs_(char *trans, int *n, int *kl, int *ku, int *nrhs, cpx8 *ab, int *ldab, cpx8 *afb, int *ldafb, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cgbsv_(int *n, int *kl, int *ku, int *nrhs, cpx8 *ab, int *ldab, int *ipiv, cpx8 *b, int *ldb, int *info);
void cgbsvx_(char *fact, char *trans, int *n, int *kl, int *ku, int *nrhs, cpx8 *ab, int *ldab, cpx8 *afb, int *ldafb, int *ipiv, char *equed, float *r, float *c, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cgbtf2_(int *m, int *n, int *kl, int *ku, cpx8 *ab, int *ldab, int *ipiv, int *info);
void cgbtrf_(int *m, int *n, int *kl, int *ku, cpx8 *ab, int *ldab, int *ipiv, int *info);
void cgbtrs_(char *trans, int *n, int *kl, int *ku, int *nrhs, cpx8 *ab, int *ldab, int *ipiv, cpx8 *b, int *ldb, int *info);
void cgebak_(char *job, char *side, int *n, int *ilo, int *ihi, float *scale, int *m, cpx8 *v, int *ldv, int *info);
void cgebal_(char *job, int *n, cpx8 *a, int *lda, int *ilo, int *ihi, float *scale, int *info);
void cgebd2_(int *m, int *n, cpx8 *a, int *lda, float *d, float *e, cpx8 *tauq, cpx8 *taup, cpx8 *work, int *info);
void cgebrd_(int *m, int *n, cpx8 *a, int *lda, float *d, float *e, cpx8 *tauq, cpx8 *taup, cpx8 *work, int *lwork, int *info);
void cgecon_(char *norm, int *n, cpx8 *a, int *lda, float *anorm, float *rcond, cpx8 *work, float *rwork, int *info);
void cgeequ_(int *m, int *n, cpx8 *a, int *lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);
void cgees_(char *jobvs, char *sort, int *select, int *n, cpx8 *a, int *lda, int *sdim, cpx8 *w, cpx8 *vs, int *ldvs, cpx8 *work, int *lwork, float *rwork, int *bwork, int *info);
void cgeesx_(char *jobvs, char *sort, int *select, char *sense, int *n, cpx8 *a, int *lda, int *sdim, cpx8 *w, cpx8 *vs, int *ldvs, float *rconde, float *rcondv, cpx8 *work, int *lwork, float *rwork, int *bwork, int *info);
void cgeev_(char *jobvl, char *jobvr, int *n, cpx8 *a, int *lda, cpx8 *w, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, cpx8 *work, int *lwork, float *rwork, int *info);
void cgeevx_(char *balanc, char *jobvl, char *jobvr, char *sense, int *n, cpx8 *a, int *lda, cpx8 *w, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, cpx8 *work, int *lwork, float *rwork, int *info);
void cgegs_(char *jobvsl, char *jobvsr, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *alpha, cpx8 *beta, cpx8 *vsl, int *ldvsl, cpx8 *vsr, int *ldvsr, cpx8 *work, int *lwork, float *rwork, int *info);
void cgegv_(char *jobvl, char *jobvr, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *alpha, cpx8 *beta, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, cpx8 *work, int *lwork, float *rwork, int *info);
void cgehd2_(int *n, int *ilo, int *ihi, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cgehrd_(int *n, int *ilo, int *ihi, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cgelq2_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cgelqf_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cgels_(char *trans, int *m, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *work, int *lwork, int *info);
void cgelss_(int *m, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, float *s, float *rcond, int *rank, cpx8 *work, int *lwork, float *rwork, int *info);
void cgelsx_(int *m, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *jpvt, float *rcond, int *rank, cpx8 *work, float *rwork, int *info);
void cgeql2_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cgeqlf_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cgeqr2_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cgeqrf_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cgerfs_(char *trans, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cgerq2_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cgerqf_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cgesv_(int *n, int *nrhs, cpx8 *a, int *lda, int *ipiv, cpx8 *b, int *ldb, int *info);
void cgesvd_(char *jobu, char *jobvt, int *m, int *n, cpx8 *a, int *lda, float *s, cpx8 *u, int *ldu, cpx8 *vt, int *ldvt, cpx8 *work, int *lwork, float *rwork, int *info);
void cgesvx_(char *fact, char *trans, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, int *ipiv, char *equed, float *r, float *c, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cgetf2_(int *m, int *n, cpx8 *a, int *lda, int *ipiv, int *info);
void cgetrf_(int *m, int *n, cpx8 *a, int *lda, int *ipiv, int *info);
void cgetri_(int *n, cpx8 *a, int *lda, int *ipiv, cpx8 *work, int *lwork, int *info);
void cgetrs_(char *trans, int *n, int *nrhs, cpx8 *a, int *lda, int *ipiv, cpx8 *b, int *ldb, int *info);
void cggbak_(char *job, char *side, int *n, int *ilo, int *ihi, float *lscale, float *rscale, int *m, cpx8 *v, int *ldv, int *info);
void cggbal_(char *job, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info);
void cggglm_(int *n, int *m, int *p, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *d, cpx8 *x, cpx8 *y, cpx8 *work, int *lwork, int *info);
void cgghrd_(char *compq, char *compz, int *n, int *ilo, int *ihi, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *q, int *ldq, cpx8 *z, int *ldz, int *info);
void cgglse_(int *m, int *n, int *p, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *c, cpx8 *d, cpx8 *x, cpx8 *work, int *lwork, int *info);
void cggqrf_(int *n, int *m, int *p, cpx8 *a, int *lda, cpx8 *taua, cpx8 *b, int *ldb, cpx8 *taub, cpx8 *work, int *lwork, int *info);
void cggrqf_(int *m, int *p, int *n, cpx8 *a, int *lda, cpx8 *taua, cpx8 *b, int *ldb, cpx8 *taub, cpx8 *work, int *lwork, int *info);
void cggsvd_(char *jobu, char *jobv, char *jobq, int *m, int *n, int *p, int *k, int *l, cpx8 *a, int *lda, cpx8 *b, int *ldb, float *alpha, float *beta, cpx8 *u, int *ldu, cpx8 *v, int *ldv, cpx8 *q, int *ldq, cpx8 *work, float *rwork, int *iwork, int *info);
void cggsvp_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, float *tola, float *tolb, int *k, int *l, cpx8 *u, int *ldu, cpx8 *v, int *ldv, cpx8 *q, int *ldq, int *iwork, float *rwork, cpx8 *tau, cpx8 *work, int *info);
void cgtcon_(char *norm, int *n, cpx8 *dl, cpx8 *d, cpx8 *du, cpx8 *du2, int *ipiv, float *anorm, float *rcond, cpx8 *work, int *info);
void cgtrfs_(char *trans, int *n, int *nrhs, cpx8 *dl, cpx8 *d, cpx8 *du, cpx8 *dlf, cpx8 *df, cpx8 *duf, cpx8 *du2, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cgtsv_(int *n, int *nrhs, cpx8 *dl, cpx8 *d, cpx8 *du, cpx8 *b, int *ldb, int *info);
void cgtsvx_(char *fact, char *trans, int *n, int *nrhs, cpx8 *dl, cpx8 *d, cpx8 *du, cpx8 *dlf, cpx8 *df, cpx8 *duf, cpx8 *du2, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cgttrf_(int *n, cpx8 *dl, cpx8 *d, cpx8 *du, cpx8 *du2, int *ipiv, int *info);
void cgttrs_(char *trans, int *n, int *nrhs, cpx8 *dl, cpx8 *d, cpx8 *du, cpx8 *du2, int *ipiv, cpx8 *b, int *ldb, int *info);
void chbev_(char *jobz, char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, float *w, cpx8 *z, int *ldz, cpx8 *work, float *rwork, int *info);
void chbevd_(char *jobz, char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, float *w, cpx8 *z, int *ldz, cpx8 *work, int *lwork, float *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void chbevx_(char *jobz, char *range, char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, cpx8 *q, int *ldq, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, cpx8 *z, int *ldz, cpx8 *work, float *rwork, int *iwork, int *ifail, int *info);
void chbgst_(char *vect, char *uplo, int *n, int *ka, int *kb, cpx8 *ab, int *ldab, cpx8 *bb, int *ldbb, cpx8 *x, int *ldx, cpx8 *work, float *rwork, int *info);
void chbgv_(char *jobz, char *uplo, int *n, int *ka, int *kb, cpx8 *ab, int *ldab, cpx8 *bb, int *ldbb, float *w, cpx8 *z, int *ldz, cpx8 *work, float *rwork, int *info);
void chbtrd_(char *vect, char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, float *d, float *e, cpx8 *q, int *ldq, cpx8 *work, int *info);
void checon_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, float *anorm, float *rcond, cpx8 *work, int *info);
void cheev_(char *jobz, char *uplo, int *n, cpx8 *a, int *lda, float *w, cpx8 *work, int *lwork, float *rwork, int *info);
void cheevd_(char *jobz, char *uplo, int *n, cpx8 *a, int *lda, float *w, cpx8 *work, int *lwork, float *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void cheevx_(char *jobz, char *range, char *uplo, int *n, cpx8 *a, int *lda, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, cpx8 *z, int *ldz, cpx8 *work, int *lwork, float *rwork, int *iwork, int *ifail, int *info);
void chegs2_(int *itype, char *uplo, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *info);
void chegst_(int *itype, char *uplo, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *info);
void chegv_(int *itype, char *jobz, char *uplo, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, float *w, cpx8 *work, int *lwork, float *rwork, int *info);
void cherfs_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void chesv_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, int *ipiv, cpx8 *b, int *ldb, cpx8 *work, int *lwork, int *info);
void chesvx_(char *fact, char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, int *lwork, float *rwork, int *info);
void chetd2_(char *uplo, int *n, cpx8 *a, int *lda, float *d, float *e, cpx8 *tau, int *info);
void chetf2_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, int *info);
void chetrd_(char *uplo, int *n, cpx8 *a, int *lda, float *d, float *e, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void chetrf_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, cpx8 *work, int *lwork, int *info);
void chetri_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, cpx8 *work, int *info);
void chetrs_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, int *ipiv, cpx8 *b, int *ldb, int *info);
void chgeqz_(char *job, char *compq, char *compz, int *n, int *ilo, int *ihi, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *alpha, cpx8 *beta, cpx8 *q, int *ldq, cpx8 *z, int *ldz, cpx8 *work, int *lwork, float *rwork, int *info);
void chpcon_(char *uplo, int *n, cpx8 *ap, int *ipiv, float *anorm, float *rcond, cpx8 *work, int *info);
void chpev_(char *jobz, char *uplo, int *n, cpx8 *ap, float *w, cpx8 *z, int *ldz, cpx8 *work, float *rwork, int *info);
void chpevd_(char *jobz, char *uplo, int *n, cpx8 *ap, float *w, cpx8 *z, int *ldz, cpx8 *work, int *lwork, float *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void chpevx_(char *jobz, char *range, char *uplo, int *n, cpx8 *ap, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, cpx8 *z, int *ldz, cpx8 *work, float *rwork, int *iwork, int *ifail, int *info);
void chpgst_(int *itype, char *uplo, int *n, cpx8 *ap, cpx8 *bp, int *info);
void chpgv_(int *itype, char *jobz, char *uplo, int *n, cpx8 *ap, cpx8 *bp, float *w, cpx8 *z, int *ldz, cpx8 *work, float *rwork, int *info);
void chprfs_(char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *afp, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void chpsv_(char *uplo, int *n, int *nrhs, cpx8 *ap, int *ipiv, cpx8 *b, int *ldb, int *info);
void chpsvx_(char *fact, char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *afp, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void chptrd_(char *uplo, int *n, cpx8 *ap, float *d, float *e, cpx8 *tau, int *info);
void chptrf_(char *uplo, int *n, cpx8 *ap, int *ipiv, int *info);
void chptri_(char *uplo, int *n, cpx8 *ap, int *ipiv, cpx8 *work, int *info);
void chptrs_(char *uplo, int *n, int *nrhs, cpx8 *ap, int *ipiv, cpx8 *b, int *ldb, int *info);
void chsein_(char *side, char *eigsrc, char *initv, int *select, int *n, cpx8 *h, int *ldh, cpx8 *w, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, int *mm, int *m, cpx8 *work, float *rwork, int *ifaill, int *ifailr, int *info);
void chseqr_(char *job, char *compz, int *n, int *ilo, int *ihi, cpx8 *h, int *ldh, cpx8 *w, cpx8 *z, int *ldz, cpx8 *work, int *lwork, int *info);
void claed0_(int *qsiz, int *n, float *d, float *e, cpx8 *q, int *ldq, cpx8 *qstore, int *ldqs, float *rwork, int *iwork, int *info);
void claed7_(int *n, int *cutpnt, int *qsiz, int *tlvls, int *curlvl, int *curpbm, float *d, cpx8 *q, int *ldq, float *rho, int *indxq, float *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, cpx8 *work, float *rwork, int *iwork, int *info);
void claed8_(int *k, int *n, int *qsiz, cpx8 *q, int *ldq, float *d, float *rho, int *cutpnt, float *z, float *dlamda, cpx8 *q2, int *ldq2, float *w, int *indxp, int *indx, int *indxq, int *perm, int *givptr, int *givcol, float *givnum, int *info);
void clahef_(char *uplo, int *n, int *nb, int *kb, cpx8 *a, int *lda, int *ipiv, cpx8 *w, int *ldw, int *info);
void clasyf_(char *uplo, int *n, int *nb, int *kb, cpx8 *a, int *lda, int *ipiv, cpx8 *w, int *ldw, int *info);
void clatzm_(char *side, int *m, int *n, cpx8 *v, int *incv, cpx8 *tau, cpx8 *c1, cpx8 *c2, int *ldc, cpx8 *work);
void cpbcon_(char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, float *anorm, float *rcond, cpx8 *work, float *rwork, int *info);
void cpbequ_(char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, float *s, float *scond, float *amax, int *info);
void cpbrfs_(char *uplo, int *n, int *kd, int *nrhs, cpx8 *ab, int *ldab, cpx8 *afb, int *ldafb, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cpbstf_(char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, int *info);
void cpbsv_(char *uplo, int *n, int *kd, int *nrhs, cpx8 *ab, int *ldab, cpx8 *b, int *ldb, int *info);
void cpbsvx_(char *fact, char *uplo, int *n, int *kd, int *nrhs, cpx8 *ab, int *ldab, cpx8 *afb, int *ldafb, char *equed, float *s, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cpbtf2_(char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, int *info);
void cpbtrf_(char *uplo, int *n, int *kd, cpx8 *ab, int *ldab, int *info);
void cpbtrs_(char *uplo, int *n, int *kd, int *nrhs, cpx8 *ab, int *ldab, cpx8 *b, int *ldb, int *info);
void cpocon_(char *uplo, int *n, cpx8 *a, int *lda, float *anorm, float *rcond, cpx8 *work, float *rwork, int *info);
void cpoequ_(int *n, cpx8 *a, int *lda, float *s, float *scond, float *amax, int *info);
void cporfs_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cposv_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *info);
void cposvx_(char *fact, char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, char *equed, float *s, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cpotf2_(char *uplo, int *n, cpx8 *a, int *lda, int *info);
void cpotrf_(char *uplo, int *n, cpx8 *a, int *lda, int *info);
void cpotri_(char *uplo, int *n, cpx8 *a, int *lda, int *info);
void cpotrs_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *info);
void cppcon_(char *uplo, int *n, cpx8 *ap, float *anorm, float *rcond, cpx8 *work, float *rwork, int *info);
void cppequ_(char *uplo, int *n, cpx8 *ap, float *s, float *scond, float *amax, int *info);
void cpprfs_(char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *afp, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cppsv_(char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *b, int *ldb, int *info);
void cppsvx_(char *fact, char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *afp, char *equed, float *s, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cpptrf_(char *uplo, int *n, cpx8 *ap, int *info);
void cpptri_(char *uplo, int *n, cpx8 *ap, int *info);
void cpptrs_(char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *b, int *ldb, int *info);
void cptcon_(int *n, float *d, cpx8 *e, float *anorm, float *rcond, float *rwork, int *info);
void cpteqr_(char *compz, int *n, float *d, float *e, cpx8 *z, int *ldz, float *work, int *info);
void cptrfs_(char *uplo, int *n, int *nrhs, float *d, cpx8 *e, float *df, cpx8 *ef, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cptsv_(int *n, int *nrhs, float *d, cpx8 *e, cpx8 *b, int *ldb, int *info);
void cptsvx_(char *fact, int *n, int *nrhs, float *d, cpx8 *e, float *df, cpx8 *ef, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cpttrf_(int *n, float *d, cpx8 *e, int *info);
void cpttrs_(char *uplo, int *n, int *nrhs, float *d, cpx8 *e, cpx8 *b, int *ldb, int *info);
void cspcon_(char *uplo, int *n, cpx8 *ap, int *ipiv, float *anorm, float *rcond, cpx8 *work, int *info);
void csprfs_(char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *afp, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void cspsv_(char *uplo, int *n, int *nrhs, cpx8 *ap, int *ipiv, cpx8 *b, int *ldb, int *info);
void cspsvx_(char *fact, char *uplo, int *n, int *nrhs, cpx8 *ap, cpx8 *afp, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void csptrf_(char *uplo, int *n, cpx8 *ap, int *ipiv, int *info);
void csptri_(char *uplo, int *n, cpx8 *ap, int *ipiv, cpx8 *work, int *info);
void csptrs_(char *uplo, int *n, int *nrhs, cpx8 *ap, int *ipiv, cpx8 *b, int *ldb, int *info);
int csrot_(int *n, void *cx, int *incx, void *cy, int *incy, float *c, float *s);
void cstedc_(char *compz, int *n, float *d, float *e, cpx8 *z, int *ldz, cpx8 *work, int *lwork, float *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void cstein_(int *n, float *d, float *e, int *m, float *w, int *iblock, int *isplit, cpx8 *z, int *ldz, float *work, int *iwork, int *ifail, int *info);
void csteqr_(char *compz, int *n, float *d, float *e, cpx8 *z, int *ldz, float *work, int *info);
void csycon_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, float *anorm, float *rcond, cpx8 *work, int *info);
void csyrfs_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void csysv_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, int *ipiv, cpx8 *b, int *ldb, cpx8 *work, int *lwork, int *info);
void csysvx_(char *fact, char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *af, int *ldaf, int *ipiv, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *rcond, float *ferr, float *berr, cpx8 *work, int *lwork, float *rwork, int *info);
void csytf2_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, int *info);
void csytrf_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, cpx8 *work, int *lwork, int *info);
void csytri_(char *uplo, int *n, cpx8 *a, int *lda, int *ipiv, cpx8 *work, int *info);
void csytrs_(char *uplo, int *n, int *nrhs, cpx8 *a, int *lda, int *ipiv, cpx8 *b, int *ldb, int *info);
void ctbcon_(char *norm, char *uplo, char *diag, int *n, int *kd, cpx8 *ab, int *ldab, float *rcond, cpx8 *work, float *rwork, int *info);
void ctbrfs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, cpx8 *ab, int *ldab, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void ctbtrs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, cpx8 *ab, int *ldab, cpx8 *b, int *ldb, int *info);
void ctgevc_(char *side, char *howmny, int *select, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, int *mm, int *m, cpx8 *work, float *rwork, int *info);
void ctgsja_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, int *k, int *l, cpx8 *a, int *lda, cpx8 *b, int *ldb, float *tola, float *tolb, float *alpha, float *beta, cpx8 *u, int *ldu, cpx8 *v, int *ldv, cpx8 *q, int *ldq, cpx8 *work, int *ncycle, int *info);
void ctpcon_(char *norm, char *uplo, char *diag, int *n, cpx8 *ap, float *rcond, cpx8 *work, float *rwork, int *info);
void ctprfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx8 *ap, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void ctptri_(char *uplo, char *diag, int *n, cpx8 *ap, int *info);
void ctptrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx8 *ap, cpx8 *b, int *ldb, int *info);
void ctrcon_(char *norm, char *uplo, char *diag, int *n, cpx8 *a, int *lda, float *rcond, cpx8 *work, float *rwork, int *info);
void ctrevc_(char *side, char *howmny, int *select, int *n, cpx8 *t, int *ldt, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, int *mm, int *m, cpx8 *work, float *rwork, int *info);
void ctrexc_(char *compq, int *n, cpx8 *t, int *ldt, cpx8 *q, int *ldq, int *ifst, int *ilst, int *info);
void ctrrfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *x, int *ldx, float *ferr, float *berr, cpx8 *work, float *rwork, int *info);
void ctrsen_(char *job, char *compq, int *select, int *n, cpx8 *t, int *ldt, cpx8 *q, int *ldq, cpx8 *w, int *m, float *s, float *sep, cpx8 *work, int *lwork, int *info);
void ctrsna_(char *job, char *howmny, int *select, int *n, cpx8 *t, int *ldt, cpx8 *vl, int *ldvl, cpx8 *vr, int *ldvr, float *s, float *sep, int *mm, int *m, cpx8 *work, int *ldwork, float *rwork, int *info);
void ctrsyl_(char *trana, char *tranb, int *isgn, int *m, int *n, cpx8 *a, int *lda, cpx8 *b, int *ldb, cpx8 *c, int *ldc, float *scale, int *info);
void ctrti2_(char *uplo, char *diag, int *n, cpx8 *a, int *lda, int *info);
void ctrtri_(char *uplo, char *diag, int *n, cpx8 *a, int *lda, int *info);
void ctrtrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx8 *a, int *lda, cpx8 *b, int *ldb, int *info);
void ctzrqf_(int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, int *info);
void cung2l_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cung2r_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cungbr_(char *vect, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cunghr_(int *n, int *ilo, int *ihi, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cungl2_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cunglq_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cungql_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cungqr_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cungr2_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *info);
void cungrq_(int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cungtr_(char *uplo, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *work, int *lwork, int *info);
void cunm2l_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *info);
void cunm2r_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *info);
void cunmbr_(char *vect, char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cunmhr_(char *side, char *trans, int *m, int *n, int *ilo, int *ihi, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cunml2_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *info);
void cunmlq_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cunmql_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cunmqr_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cunmr2_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *info);
void cunmrq_(char *side, char *trans, int *m, int *n, int *k, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cunmtr_(char *side, char *uplo, char *trans, int *m, int *n, cpx8 *a, int *lda, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *lwork, int *info);
void cupgtr_(char *uplo, int *n, cpx8 *ap, cpx8 *tau, cpx8 *q, int *ldq, cpx8 *work, int *info);
void cupmtr_(char *side, char *uplo, char *trans, int *m, int *n, cpx8 *ap, cpx8 *tau, cpx8 *c, int *ldc, cpx8 *work, int *info);
void sbdsqr_(char *uplo, int *n, int *ncvt, int *nru, int *ncc, float *d, float *e, float *vt, int *ldvt, float *u, int *ldu, float *c, int *ldc, float *work, int *info);
void sdisna_(char *job, int *m, int *n, float *d, float *sep, int *info);
void sgbbrd_(char *vect, int *m, int *n, int *ncc, int *kl, int *ku, float *ab, int *ldab, float *d, float *e, float *q, int *ldq, float *pt, int *ldpt, float *c, int *ldc, float *work, int *info);
void sgbcon_(char *norm, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);
void sgbequ_(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);
void sgbrfs_(char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void sgbsv_(int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, int *ipiv, float *b, int *ldb, int *info);
void sgbsvx_(char *fact, char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void sgbtf2_(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, int *info);
void sgbtrf_(int *m, int *n, int *kl, int *ku, float *ab, int *ldab, int *ipiv, int *info);
void sgbtrs_(char *trans, int *n, int *kl, int *ku, int *nrhs, float *ab, int *ldab, int *ipiv, float *b, int *ldb, int *info);
void sgebak_(char *job, char *side, int *n, int *ilo, int *ihi, float *scale, int *m, float *v, int *ldv, int *info);
void sgebal_(char *job, int *n, float *a, int *lda, int *ilo, int *ihi, float *scale, int *info);
void sgebd2_(int *m, int *n, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *work, int *info);
void sgebrd_(int *m, int *n, float *a, int *lda, float *d, float *e, float *tauq, float *taup, float *work, int *lwork, int *info);
void sgecon_(char *norm, int *n, float *a, int *lda, float *anorm, float *rcond, float *work, int *iwork, int *info);
void sgeequ_(int *m, int *n, float *a, int *lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax, int *info);
void sgees_(char *jobvs, char *sort, int *select, int *n, float *a, int *lda, int *sdim, float *wr, float *wi, float *vs, int *ldvs, float *work, int *lwork, int *bwork, int *info);
void sgeesx_(char *jobvs, char *sort, int *select, char *sense, int *n, float *a, int *lda, int *sdim, float *wr, float *wi, float *vs, int *ldvs, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *liwork, int *bwork, int *info);
void sgeev_(char *jobvl, char *jobvr, int *n, float *a, int *lda, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);
void sgeevx_(char *balanc, char *jobvl, char *jobvr, char *sense, int *n, float *a, int *lda, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int *lwork, int *iwork, int *info);
void sgegs_(char *jobvsl, char *jobvsr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vsl, int *ldvsl, float *vsr, int *ldvsr, float *work, int *lwork, int *info);
void sgegv_(char *jobvl, char *jobvr, int *n, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *vl, int *ldvl, float *vr, int *ldvr, float *work, int *lwork, int *info);
void sgehd2_(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *info);
void sgehrd_(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sgelq2_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);
void sgelqf_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sgels_(char *trans, int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *work, int *lwork, int *info);
void sgelss_(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *s, float *rcond, int *rank, float *work, int *lwork, int *info);
void sgelsx_(int *m, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *jpvt, float *rcond, int *rank, float *work, int *info);
void sgeql2_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);
void sgeqlf_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sgeqp3_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *lwork, int *info);
void sgeqr2_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);
void sgeqrf_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sgerfs_(char *trans, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void sgerq2_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *info);
void sgerqf_(int *m, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sgesv_(int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);
void sgesvd_(char *jobu, char *jobvt, int *m, int *n, float *a, int *lda, float *s, float *u, int *ldu, float *vt, int *ldvt, float *work, int *lwork, int *info);
void sgesvx_(char *fact, char *trans, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void sgetf2_(int *m, int *n, float *a, int *lda, int *ipiv, int *info);
void sgetrf_(int *m, int *n, float *a, int *lda, int *ipiv, int *info);
void sgetri_(int *n, float *a, int *lda, int *ipiv, float *work, int *lwork, int *info);
void sgetrs_(char *trans, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);
void sggbak_(char *job, char *side, int *n, int *ilo, int *ihi, float *lscale, float *rscale, int *m, float *v, int *ldv, int *info);
void sggbal_(char *job, int *n, float *a, int *lda, float *b, int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info);
void sggglm_(int *n, int *m, int *p, float *a, int *lda, float *b, int *ldb, float *d, float *x, float *y, float *work, int *lwork, int *info);
void sgghrd_(char *compq, char *compz, int *n, int *ilo, int *ihi, float *a, int *lda, float *b, int *ldb, float *q, int *ldq, float *z, int *ldz, int *info);
void sgglse_(int *m, int *n, int *p, float *a, int *lda, float *b, int *ldb, float *c, float *d, float *x, float *work, int *lwork, int *info);
void sggqrf_(int *n, int *m, int *p, float *a, int *lda, float *taua, float *b, int *ldb, float *taub, float *work, int *lwork, int *info);
void sggrqf_(int *m, int *p, int *n, float *a, int *lda, float *taua, float *b, int *ldb, float *taub, float *work, int *lwork, int *info);
void sggsvd_(char *jobu, char *jobv, char *jobq, int *m, int *n, int *p, int *k, int *l, float *a, int *lda, float *b, int *ldb, float *alpha, float *beta, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, float *work, int *iwork, int *info);
void sggsvp_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, float *a, int *lda, float *b, int *ldb, float *tola, float *tolb, int *k, int *l, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, int *iwork, float *tau, float *work, int *info);
void sgtcon_(char *norm, int *n, float *dl, float *d, float *du, float *du2, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);
void sgtrfs_(char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void sgtsv_(int *n, int *nrhs, float *dl, float *d, float *du, float *b, int *ldb, int *info);
void sgtsvx_(char *fact, char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void sgttrf_(int *n, float *dl, float *d, float *du, float *du2, int *ipiv, int *info);
void sgttrs_(char *trans, int *n, int *nrhs, float *dl, float *d, float *du, float *du2, int *ipiv, float *b, int *ldb, int *info);
void shgeqz_(char *job, char *compq, char *compz, int *n, int *ilo, int *ihi, float *a, int *lda, float *b, int *ldb, float *alphar, float *alphai, float *beta, float *q, int *ldq, float *z, int *ldz, float *work, int *lwork, int *info);
void shsein_(char *side, char *eigsrc, char *initv, int *select, int *n, float *h, int *ldh, float *wr, float *wi, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *ifaill, int *ifailr, int *info);
void shseqr_(char *job, char *compz, int *n, int *ilo, int *ihi, float *h, int *ldh, float *wr, float *wi, float *z, int *ldz, float *work, int *lwork, int *info);
void slaed0_(int *icompq, int *qsiz, int *n, float *d, float *e, float *q, int *ldq, float *qstore, int *ldqs, float *work, int *iwork, int *info);
void slaed1_(int *n, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *work, int *iwork, int *info);
void slaed2_(int *k, int *n, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *z, float *dlamda, float *q2, int *ldq2, int *indxc, float *w, int *indxp, int *indx, int *coltyp, int *info);
void slaed3_(int *k, int *kstart, int *kstop, int *n, float *d, float *q, int *ldq, float *rho, int *cutpnt, float *dlamda, float *q2, int *ldq2, int *indxc, int *ctot, float *w, float *s, int *lds, int *info);
void slaed4_(int *n, int *i, float *d, float *z, float *delta, float *rho, float *dlam, int *info);
void slaed5_(int *i, float *d, float *z, float *delta, float *rho, float *dlam);
void slaed6_(int *kniter, int *orgati, float *rho, float *d, float *z, float *finit, float *tau, int *info);
void slaed7_(int *icompq, int *n, int *qsiz, int *tlvls, int *curlvl, int *curpbm, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, float *work, int *iwork, int *info);
void slaed8_(int *icompq, int *k, int *n, int *qsiz, float *d, float *q, int *ldq, int *indxq, float *rho, int *cutpnt, float *z, float *dlamda, float *q2, int *ldq2, float *w, int *perm, int *givptr, int *givcol, float *givnum, int *indxp, int *indx, int *info);
void slaed9_(int *k, int *kstart, int *kstop, int *n, float *d, float *q, int *ldq, float *rho, float *dlamda, float *w, float *s, int *lds, int *info);
void slaeda_(int *n, int *tlvls, int *curlvl, int *curpbm, int *prmptr, int *perm, int *givptr, int *givcol, float *givnum, float *q, int *qptr, float *z, float *ztemp, int *info);
void slagtf_(int *n, float *a, float *lambda, float *b, float *c, float *tol, float *d, int *in, int *info);
void slamrg_(int *n1, int *n2, float *a, int *strd1, int *strd2, int *index);
void slasq1_(int *n, float *d, float *e, float *work, int *info);
void slasq2_(int *m, float *q, float *e, float *qq, float *ee, float *eps, float *tol2, float *small2, float *sup, int *kend, int *info);
void slasq3_(int *n, float *q, float *e, float *qq, float *ee, float *sup, float *sigma, int *kend, int *off, int *iphase, int *iconv, float *eps, float *tol2, float *small2);
void slasq4_(int *n, float *q, float *e, float *tau, float *sup);
void slasrt_(char *id, int *n, float *d, int *info);
void slatzm_(char *side, int *m, int *n, float *v, int *incv, float *tau, float *c1, float *c2, int *ldc, float *work);
void sopgtr_(char *uplo, int *n, float *ap, float *tau, float *q, int *ldq, float *work, int *info);
void sopmtr_(char *side, char *uplo, char *trans, int *m, int *n, float *ap, float *tau, float *c, int *ldc, float *work, int *info);
void sorg2l_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);
void sorg2r_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);
void sorgbr_(char *vect, int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorghr_(int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorgl2_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);
void sorglq_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorgql_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorgqr_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorgr2_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *info);
void sorgrq_(int *m, int *n, int *k, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorgtr_(char *uplo, int *n, float *a, int *lda, float *tau, float *work, int *lwork, int *info);
void sorm2l_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *info);
void sorm2r_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *info);
void sormbr_(char *vect, char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void sormhr_(char *side, char *trans, int *m, int *n, int *ilo, int *ihi, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void sorml2_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *info);
void sormlq_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void sormql_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void sormqr_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void sormr2_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *info);
void sormrq_(char *side, char *trans, int *m, int *n, int *k, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void sormtr_(char *side, char *uplo, char *trans, int *m, int *n, float *a, int *lda, float *tau, float *c, int *ldc, float *work, int *lwork, int *info);
void spbcon_(char *uplo, int *n, int *kd, float *ab, int *ldab, float *anorm, float *rcond, float *work, int *iwork, int *info);
void spbequ_(char *uplo, int *n, int *kd, float *ab, int *ldab, float *s, float *scond, float *amax, int *info);
void spbrfs_(char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void spbstf_(char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);
void spbsv_(char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);
void spbsvx_(char *fact, char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *afb, int *ldafb, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void spbtf2_(char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);
void spbtrf_(char *uplo, int *n, int *kd, float *ab, int *ldab, int *info);
void spbtrs_(char *uplo, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);
void spocon_(char *uplo, int *n, float *a, int *lda, float *anorm, float *rcond, float *work, int *iwork, int *info);
void spoequ_(int *n, float *a, int *lda, float *s, float *scond, float *amax, int *info);
void sporfs_(char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void sposv_(char *uplo, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);
void sposvx_(char *fact, char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void spotf2_(char *uplo, int *n, float *a, int *lda, int *info);
void spotrf_(char *uplo, int *n, float *a, int *lda, int *info);
void spotri_(char *uplo, int *n, float *a, int *lda, int *info);
void spotrs_(char *uplo, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);
void sppcon_(char *uplo, int *n, float *ap, float *anorm, float *rcond, float *work, int *iwork, int *info);
void sppequ_(char *uplo, int *n, float *ap, float *s, float *scond, float *amax, int *info);
void spprfs_(char *uplo, int *n, int *nrhs, float *ap, float *afp, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void sppsv_(char *uplo, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);
void sppsvx_(char *fact, char *uplo, int *n, int *nrhs, float *ap, float *afp, char *equed, float *s, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void spptrf_(char *uplo, int *n, float *ap, int *info);
void spptri_(char *uplo, int *n, float *ap, int *info);
void spptrs_(char *uplo, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);
void sptcon_(int *n, float *d, float *e, float *anorm, float *rcond, float *work, int *info);
void spteqr_(char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);
void sptrfs_(int *n, int *nrhs, float *d, float *e, float *df, float *ef, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *info);
void sptsv_(int *n, int *nrhs, float *d, float *e, float *b, int *ldb, int *info);
void sptsvx_(char *fact, int *n, int *nrhs, float *d, float *e, float *df, float *ef, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info);
void spttrf_(int *n, float *d, float *e, int *info);
void spttrs_(int *n, int *nrhs, float *d, float *e, float *b, int *ldb, int *info);
void ssbev_(char *jobz, char *uplo, int *n, int *kd, float *ab, int *ldab, float *w, float *z, int *ldz, float *work, int *info);
void ssbevd_(char *jobz, char *uplo, int *n, int *kd, float *ab, int *ldab, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);
void ssbevx_(char *jobz, char *range, char *uplo, int *n, int *kd, float *ab, int *ldab, float *q, int *ldq, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);
void ssbgst_(char *vect, char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *x, int *ldx, float *work, int *info);
void ssbgv_(char *jobz, char *uplo, int *n, int *ka, int *kb, float *ab, int *ldab, float *bb, int *ldbb, float *w, float *z, int *ldz, float *work, int *info);
void ssbtrd_(char *vect, char *uplo, int *n, int *kd, float *ab, int *ldab, float *d, float *e, float *q, int *ldq, float *work, int *info);
void sspcon_(char *uplo, int *n, float *ap, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);
void sspev_(char *jobz, char *uplo, int *n, float *ap, float *w, float *z, int *ldz, float *work, int *info);
void sspevd_(char *jobz, char *uplo, int *n, float *ap, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);
void sspevx_(char *jobz, char *range, char *uplo, int *n, float *ap, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);
void sspgst_(int *itype, char *uplo, int *n, float *ap, float *bp, int *info);
void sspgv_(int *itype, char *jobz, char *uplo, int *n, float *ap, float *bp, float *w, float *z, int *ldz, float *work, int *info);
void ssprfs_(char *uplo, int *n, int *nrhs, float *ap, float *afp, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void sspsv_(char *uplo, int *n, int *nrhs, float *ap, int *ipiv, float *b, int *ldb, int *info);
void sspsvx_(char *fact, char *uplo, int *n, int *nrhs, float *ap, float *afp, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info);
void ssptrd_(char *uplo, int *n, float *ap, float *d, float *e, float *tau, int *info);
void ssptrf_(char *uplo, int *n, float *ap, int *ipiv, int *info);
void ssptri_(char *uplo, int *n, float *ap, int *ipiv, float *work, int *info);
void ssptrs_(char *uplo, int *n, int *nrhs, float *ap, int *ipiv, float *b, int *ldb, int *info);
void sstebz_(char *range, char *order, int *n, float *vl, float *vu, int *il, int *iu, float *abstol, float *d, float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit, float *work, int *iwork, int *info);
void sstedc_(char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);
void sstein_(int *n, float *d, float *e, int *m, float *w, int *iblock, int *isplit, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);
void ssteqr_(char *compz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);
void ssterf_(int *n, float *d, float *e, int *info);
void sstev_(char *jobz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *info);
void sstevd_(char *jobz, int *n, float *d, float *e, float *z, int *ldz, float *work, int *lwork, int *iwork, int *liwork, int *info);
void sstevx_(char *jobz, char *range, int *n, float *d, float *e, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *iwork, int *ifail, int *info);
void ssycon_(char *uplo, int *n, float *a, int *lda, int *ipiv, float *anorm, float *rcond, float *work, int *iwork, int *info);
void ssyev_(char *jobz, char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *info);
void ssyevd_(char *jobz, char *uplo, int *n, float *a, int *lda, float *w, float *work, int *lwork, int *iwork, int *liwork, int *info);
void ssyevx_(char *jobz, char *range, char *uplo, int *n, float *a, int *lda, float *vl, float *vu, int *il, int *iu, float *abstol, int *m, float *w, float *z, int *ldz, float *work, int *lwork, int *iwork, int *ifail, int *info);
void ssygs2_(int *itype, char *uplo, int *n, float *a, int *lda, float *b, int *ldb, int *info);
void ssygst_(int *itype, char *uplo, int *n, float *a, int *lda, float *b, int *ldb, int *info);
void ssygv_(int *itype, char *jobz, char *uplo, int *n, float *a, int *lda, float *b, int *ldb, float *w, float *work, int *lwork, int *info);
void ssyrfs_(char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void ssysv_(char *uplo, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, float *work, int *lwork, int *info);
void ssysvx_(char *fact, char *uplo, int *n, int *nrhs, float *a, int *lda, float *af, int *ldaf, int *ipiv, float *b, int *ldb, float *x, int *ldx, float *rcond, float *ferr, float *berr, float *work, int *lwork, int *iwork, int *info);
void ssytd2_(char *uplo, int *n, float *a, int *lda, float *d, float *e, float *tau, int *info);
void ssytf2_(char *uplo, int *n, float *a, int *lda, int *ipiv, int *info);
void ssytrd_(char *uplo, int *n, float *a, int *lda, float *d, float *e, float *tau, float *work, int *lwork, int *info);
void ssytrf_(char *uplo, int *n, float *a, int *lda, int *ipiv, float *work, int *lwork, int *info);
void ssytri_(char *uplo, int *n, float *a, int *lda, int *ipiv, float *work, int *info);
void ssytrs_(char *uplo, int *n, int *nrhs, float *a, int *lda, int *ipiv, float *b, int *ldb, int *info);
void stbcon_(char *norm, char *uplo, char *diag, int *n, int *kd, float *ab, int *ldab, float *rcond, float *work, int *iwork, int *info);
void stbrfs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void stbtrs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, float *ab, int *ldab, float *b, int *ldb, int *info);
void stgevc_(char *side, char *howmny, int *select, int *n, float *a, int *lda, float *b, int *ldb, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *info);
void stgsja_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, int *k, int *l, float *a, int *lda, float *b, int *ldb, float *tola, float *tolb, float *alpha, float *beta, float *u, int *ldu, float *v, int *ldv, float *q, int *ldq, float *work, int *ncycle, int *info);
void stpcon_(char *norm, char *uplo, char *diag, int *n, float *ap, float *rcond, float *work, int *iwork, int *info);
void stprfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, float *ap, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void stptri_(char *uplo, char *diag, int *n, float *ap, int *info);
void stptrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, float *ap, float *b, int *ldb, int *info);
void strcon_(char *norm, char *uplo, char *diag, int *n, float *a, int *lda, float *rcond, float *work, int *iwork, int *info);
void strevc_(char *side, char *howmny, int *select, int *n, float *t, int *ldt, float *vl, int *ldvl, float *vr, int *ldvr, int *mm, int *m, float *work, int *info);
void strexc_(char *compq, int *n, float *t, int *ldt, float *q, int *ldq, int *ifst, int *ilst, float *work, int *info);
void strrfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, float *x, int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info);
void strsen_(char *job, char *compq, int *select, int *n, float *t, int *ldt, float *q, int *ldq, float *wr, float *wi, int *m, float *s, float *sep, float *work, int *lwork, int *iwork, int *liwork, int *info);
void strsna_(char *job, char *howmny, int *select, int *n, float *t, int *ldt, float *vl, int *ldvl, float *vr, int *ldvr, float *s, float *sep, int *mm, int *m, float *work, int *ldwork, int *iwork, int *info);
void strsyl_(char *trana, char *tranb, int *isgn, int *m, int *n, float *a, int *lda, float *b, int *ldb, float *c, int *ldc, float *scale, int *info);
void strti2_(char *uplo, char *diag, int *n, float *a, int *lda, int *info);
void strtri_(char *uplo, char *diag, int *n, float *a, int *lda, int *info);
void strtrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, float *a, int *lda, float *b, int *ldb, int *info);
void stzrqf_(int *m, int *n, float *a, int *lda, float *tau, int *info);

void dbdsqr_(char *uplo, int *n, int *ncvt, int *nru, int *ncc, double *d, double *e, double *vt, int *ldvt, double *u, int *ldu, double *c, int *ldc, double *work, int *info);
void ddisna_(char *job, int *m, int *n, double *d, double *sep, int *info);
void dgbbrd_(char *vect, int *m, int *n, int *ncc, int *kl, int *ku, double *ab, int *ldab, double *d, double *e, double *q, int *ldq, double *pt, int *ldpt, double *c, int *ldc, double *work, int *info);
void dgbcon_(char *norm, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dgbequ_(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);
void dgbrfs_(char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dgbsv_(int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, int *ipiv, double *b, int *ldb, int *info);
void dgbsvx_(char *fact, char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dgbtf2_(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, int *info);
void dgbtrf_(int *m, int *n, int *kl, int *ku, double *ab, int *ldab, int *ipiv, int *info);
void dgbtrs_(char *trans, int *n, int *kl, int *ku, int *nrhs, double *ab, int *ldab, int *ipiv, double *b, int *ldb, int *info);
void dgebak_(char *job, char *side, int *n, int *ilo, int *ihi, double *scale, int *m, double *v, int *ldv, int *info);
void dgebal_(char *job, int *n, double *a, int *lda, int *ilo, int *ihi, double *scale, int *info);
void dgebd2_(int *m, int *n, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *work, int *info);
void dgebrd_(int *m, int *n, double *a, int *lda, double *d, double *e, double *tauq, double *taup, double *work, int *lwork, int *info);
void dgecon_(char *norm, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dgeequ_(int *m, int *n, double *a, int *lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);
void dgees_(char *jobvs, char *sort, int *select, int *n, double *a, int *lda, int *sdim, double *wr, double *wi, double *vs, int *ldvs, double *work, int *lwork, int *bwork, int *info);
void dgeesx_(char *jobvs, char *sort, int *select, char *sense, int *n, double *a, int *lda, int *sdim, double *wr, double *wi, double *vs, int *ldvs, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *liwork, int *bwork, int *info);
void dgeev_(char *jobvl, char *jobvr, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);
void dgeevx_(char *balanc, char *jobvl, char *jobvr, char *sense, int *n, double *a, int *lda, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int *lwork, int *iwork, int *info);
void dgegs_(char *jobvsl, char *jobvsr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vsl, int *ldvsl, double *vsr, int *ldvsr, double *work, int *lwork, int *info);
void dgegv_(char *jobvl, char *jobvr, int *n, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *vl, int *ldvl, double *vr, int *ldvr, double *work, int *lwork, int *info);
void dgehd2_(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *info);
void dgehrd_(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dgelq2_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);
void dgelqf_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dgels_(char *trans, int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *work, int *lwork, int *info);
void dgelss_(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *s, double *rcond, int *rank, double *work, int *lwork, int *info);
void dgelsx_(int *m, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *jpvt, double *rcond, int *rank, double *work, int *info);
void dgeql2_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);
void dgeqlf_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dgeqp3_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *lwork, int *info);
void dgeqr2_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);
void dgeqrf_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dgerfs_(char *trans, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dgerq2_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *info);
void dgerqf_(int *m, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dgesv_(int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);
void dgesvd_(char *jobu, char *jobvt, int *m, int *n, double *a, int *lda, double *s, double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *info);
void dgesvx_(char *fact, char *trans, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dgetf2_(int *m, int *n, double *a, int *lda, int *ipiv, int *info);
void dgetrf_(int *m, int *n, double *a, int *lda, int *ipiv, int *info);
void dgetri_(int *n, double *a, int *lda, int *ipiv, double *work, int *lwork, int *info);
void dgetrs_(char *trans, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);
void dggbak_(char *job, char *side, int *n, int *ilo, int *ihi, double *lscale, double *rscale, int *m, double *v, int *ldv, int *info);
void dggbal_(char *job, int *n, double *a, int *lda, double *b, int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info);
void dggglm_(int *n, int *m, int *p, double *a, int *lda, double *b, int *ldb, double *d, double *x, double *y, double *work, int *lwork, int *info);
void dgghrd_(char *compq, char *compz, int *n, int *ilo, int *ihi, double *a, int *lda, double *b, int *ldb, double *q, int *ldq, double *z, int *ldz, int *info);
void dgglse_(int *m, int *n, int *p, double *a, int *lda, double *b, int *ldb, double *c, double *d, double *x, double *work, int *lwork, int *info);
void dggqrf_(int *n, int *m, int *p, double *a, int *lda, double *taua, double *b, int *ldb, double *taub, double *work, int *lwork, int *info);
void dggrqf_(int *m, int *p, int *n, double *a, int *lda, double *taua, double *b, int *ldb, double *taub, double *work, int *lwork, int *info);
void dggsvd_(char *jobu, char *jobv, char *jobq, int *m, int *n, int *p, int *k, int *l, double *a, int *lda, double *b, int *ldb, double *alpha, double *beta, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, double *work, int *iwork, int *info);
void dggsvp_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, double *a, int *lda, double *b, int *ldb, double *tola, double *tolb, int *k, int *l, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, int *iwork, double *tau, double *work, int *info);
void dgtcon_(char *norm, int *n, double *dl, double *d, double *du, double *du2, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dgtrfs_(char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dgtsv_(int *n, int *nrhs, double *dl, double *d, double *du, double *b, int *ldb, int *info);
void dgtsvx_(char *fact, char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dgttrf_(int *n, double *dl, double *d, double *du, double *du2, int *ipiv, int *info);
void dgttrs_(char *trans, int *n, int *nrhs, double *dl, double *d, double *du, double *du2, int *ipiv, double *b, int *ldb, int *info);
void dhgeqz_(char *job, char *compq, char *compz, int *n, int *ilo, int *ihi, double *a, int *lda, double *b, int *ldb, double *alphar, double *alphai, double *beta, double *q, int *ldq, double *z, int *ldz, double *work, int *lwork, int *info);
void dhsein_(char *side, char *eigsrc, char *initv, int *select, int *n, double *h, int *ldh, double *wr, double *wi, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *ifaill, int *ifailr, int *info);
void dhseqr_(char *job, char *compz, int *n, int *ilo, int *ihi, double *h, int *ldh, double *wr, double *wi, double *z, int *ldz, double *work, int *lwork, int *info);
void dlaed0_(int *icompq, int *qsiz, int *n, double *d, double *e, double *q, int *ldq, double *qstore, int *ldqs, double *work, int *iwork, int *info);
void dlaed1_(int *n, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *work, int *iwork, int *info);
void dlaed2_(int *k, int *n, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *z, double *dlamda, double *q2, int *ldq2, int *indxc, double *w, int *indxp, int *indx, int *coltyp, int *info);
void dlaed3_(int *k, int *kstart, int *kstop, int *n, double *d, double *q, int *ldq, double *rho, int *cutpnt, double *dlamda, double *q2, int *ldq2, int *indxc, int *ctot, double *w, double *s, int *lds, int *info);
void dlaed4_(int *n, int *i, double *d, double *z, double *delta, double *rho, double *dlam, int *info);
void dlaed5_(int *i, double *d, double *z, double *delta, double *rho, double *dlam);
void dlaed6_(int *kniter, int *orgati, double *rho, double *d, double *z, double *finit, double *tau, int *info);
void dlaed7_(int *icompq, int *n, int *qsiz, int *tlvls, int *curlvl, int *curpbm, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, double *work, int *iwork, int *info);
void dlaed8_(int *icompq, int *k, int *n, int *qsiz, double *d, double *q, int *ldq, int *indxq, double *rho, int *cutpnt, double *z, double *dlamda, double *q2, int *ldq2, double *w, int *perm, int *givptr, int *givcol, double *givnum, int *indxp, int *indx, int *info);
void dlaed9_(int *k, int *kstart, int *kstop, int *n, double *d, double *q, int *ldq, double *rho, double *dlamda, double *w, double *s, int *lds, int *info);
void dlaeda_(int *n, int *tlvls, int *curlvl, int *curpbm, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, double *q, int *qptr, double *z, double *ztemp, int *info);
void dlagtf_(int *n, double *a, double *lambda, double *b, double *c, double *tol, double *d, int *in, int *info);
void dlamrg_(int *n1, int *n2, double *a, int *dtrd1, int *dtrd2, int *index);
void dlasq1_(int *n, double *d, double *e, double *work, int *info);
void dlasq2_(int *m, double *q, double *e, double *qq, double *ee, double *eps, double *tol2, double *small2, double *sup, int *kend, int *info);
void dlasq3_(int *n, double *q, double *e, double *qq, double *ee, double *sup, double *sigma, int *kend, int *off, int *iphase, int *iconv, double *eps, double *tol2, double *small2);
void dlasq4_(int *n, double *q, double *e, double *tau, double *sup);
void dlasrt_(char *id, int *n, double *d, int *info);
void dlatzm_(char *side, int *m, int *n, double *v, int *incv, double *tau, double *c1, double *c2, int *ldc, double *work);
void dopgtr_(char *uplo, int *n, double *ap, double *tau, double *q, int *ldq, double *work, int *info);
void dopmtr_(char *side, char *uplo, char *trans, int *m, int *n, double *ap, double *tau, double *c, int *ldc, double *work, int *info);
void dorg2l_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);
void dorg2r_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);
void dorgbr_(char *vect, int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorghr_(int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorgl2_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);
void dorglq_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorgql_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorgqr_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorgr2_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *info);
void dorgrq_(int *m, int *n, int *k, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorgtr_(char *uplo, int *n, double *a, int *lda, double *tau, double *work, int *lwork, int *info);
void dorm2l_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *info);
void dorm2r_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *info);
void dormbr_(char *vect, char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dormhr_(char *side, char *trans, int *m, int *n, int *ilo, int *ihi, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dorml2_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *info);
void dormlq_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dormql_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dormqr_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dormr2_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *info);
void dormrq_(char *side, char *trans, int *m, int *n, int *k, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dormtr_(char *side, char *uplo, char *trans, int *m, int *n, double *a, int *lda, double *tau, double *c, int *ldc, double *work, int *lwork, int *info);
void dpbcon_(char *uplo, int *n, int *kd, double *ab, int *ldab, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dpbequ_(char *uplo, int *n, int *kd, double *ab, int *ldab, double *s, double *scond, double *amax, int *info);
void dpbrfs_(char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dpbstf_(char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);
void dpbsv_(char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);
void dpbsvx_(char *fact, char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *afb, int *ldafb, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dpbtf2_(char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);
void dpbtrf_(char *uplo, int *n, int *kd, double *ab, int *ldab, int *info);
void dpbtrs_(char *uplo, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);
void dpocon_(char *uplo, int *n, double *a, int *lda, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dpoequ_(int *n, double *a, int *lda, double *s, double *scond, double *amax, int *info);
void dporfs_(char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dposv_(char *uplo, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);
void dposvx_(char *fact, char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dpotf2_(char *uplo, int *n, double *a, int *lda, int *info);
void dpotrf_(char *uplo, int *n, double *a, int *lda, int *info);
void dpotri_(char *uplo, int *n, double *a, int *lda, int *info);
void dpotrs_(char *uplo, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);
void dppcon_(char *uplo, int *n, double *ap, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dppequ_(char *uplo, int *n, double *ap, double *s, double *scond, double *amax, int *info);
void dpprfs_(char *uplo, int *n, int *nrhs, double *ap, double *afp, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dppsv_(char *uplo, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);
void dppsvx_(char *fact, char *uplo, int *n, int *nrhs, double *ap, double *afp, char *equed, double *s, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dpptrf_(char *uplo, int *n, double *ap, int *info);
void dpptri_(char *uplo, int *n, double *ap, int *info);
void dpptrs_(char *uplo, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);
void dptcon_(int *n, double *d, double *e, double *anorm, double *rcond, double *work, int *info);
void dpteqr_(char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);
void dptrfs_(int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *info);
void dptsv_(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);
void dptsvx_(char *fact, int *n, int *nrhs, double *d, double *e, double *df, double *ef, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info);
void dpttrf_(int *n, double *d, double *e, int *info);
void dpttrs_(int *n, int *nrhs, double *d, double *e, double *b, int *ldb, int *info);
void dsbev_(char *jobz, char *uplo, int *n, int *kd, double *ab, int *ldab, double *w, double *z, int *ldz, double *work, int *info);
void dsbevd_(char *jobz, char *uplo, int *n, int *kd, double *ab, int *ldab, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);
void dsbevx_(char *jobz, char *range, char *uplo, int *n, int *kd, double *ab, int *ldab, double *q, int *ldq, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);
void dsbgst_(char *vect, char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *x, int *ldx, double *work, int *info);
void dsbgv_(char *jobz, char *uplo, int *n, int *ka, int *kb, double *ab, int *ldab, double *bb, int *ldbb, double *w, double *z, int *ldz, double *work, int *info);
void dsbtrd_(char *vect, char *uplo, int *n, int *kd, double *ab, int *ldab, double *d, double *e, double *q, int *ldq, double *work, int *info);
void dspcon_(char *uplo, int *n, double *ap, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dspev_(char *jobz, char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *info);
void dspevd_(char *jobz, char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);
void dspevx_(char *jobz, char *range, char *uplo, int *n, double *ap, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);
void dspgst_(int *itype, char *uplo, int *n, double *ap, double *bp, int *info);
void dspgv_(int *itype, char *jobz, char *uplo, int *n, double *ap, double *bp, double *w, double *z, int *ldz, double *work, int *info);
void dsprfs_(char *uplo, int *n, int *nrhs, double *ap, double *afp, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dspsv_(char *uplo, int *n, int *nrhs, double *ap, int *ipiv, double *b, int *ldb, int *info);
void dspsvx_(char *fact, char *uplo, int *n, int *nrhs, double *ap, double *afp, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info);
void dsptrd_(char *uplo, int *n, double *ap, double *d, double *e, double *tau, int *info);
void dsptrf_(char *uplo, int *n, double *ap, int *ipiv, int *info);
void dsptri_(char *uplo, int *n, double *ap, int *ipiv, double *work, int *info);
void dsptrs_(char *uplo, int *n, int *nrhs, double *ap, int *ipiv, double *b, int *ldb, int *info);
void dstebz_(char *range, char *order, int *n, double *vl, double *vu, int *il, int *iu, double *abstol, double *d, double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit, double *work, int *iwork, int *info);
void dstedc_(char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);
void dstein_(int *n, double *d, double *e, int *m, double *w, int *iblock, int *isplit, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);
void dsteqr_(char *compz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);
void dsterf_(int *n, double *d, double *e, int *info);
void dstev_(char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *info);
void dstevd_(char *jobz, int *n, double *d, double *e, double *z, int *ldz, double *work, int *lwork, int *iwork, int *liwork, int *info);
void dstevx_(char *jobz, char *range, int *n, double *d, double *e, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *iwork, int *ifail, int *info);
void dsycon_(char *uplo, int *n, double *a, int *lda, int *ipiv, double *anorm, double *rcond, double *work, int *iwork, int *info);
void dsyev_(char *jobz, char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *info);
void dsyevd_(char *jobz, char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *iwork, int *liwork, int *info);
void dsyevx_(char *jobz, char *range, char *uplo, int *n, double *a, int *lda, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, double *z, int *ldz, double *work, int *lwork, int *iwork, int *ifail, int *info);
void dsygs2_(int *itype, char *uplo, int *n, double *a, int *lda, double *b, int *ldb, int *info);
void dsygst_(int *itype, char *uplo, int *n, double *a, int *lda, double *b, int *ldb, int *info);
void dsygv_(int *itype, char *jobz, char *uplo, int *n, double *a, int *lda, double *b, int *ldb, double *w, double *work, int *lwork, int *info);
void dsyrfs_(char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dsysv_(char *uplo, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, double *work, int *lwork, int *info);
void dsysvx_(char *fact, char *uplo, int *n, int *nrhs, double *a, int *lda, double *af, int *ldaf, int *ipiv, double *b, int *ldb, double *x, int *ldx, double *rcond, double *ferr, double *berr, double *work, int *lwork, int *iwork, int *info);
void dsytd2_(char *uplo, int *n, double *a, int *lda, double *d, double *e, double *tau, int *info);
void dsytf2_(char *uplo, int *n, double *a, int *lda, int *ipiv, int *info);
void dsytrd_(char *uplo, int *n, double *a, int *lda, double *d, double *e, double *tau, double *work, int *lwork, int *info);
void dsytrf_(char *uplo, int *n, double *a, int *lda, int *ipiv, double *work, int *lwork, int *info);
void dsytri_(char *uplo, int *n, double *a, int *lda, int *ipiv, double *work, int *info);
void dsytrs_(char *uplo, int *n, int *nrhs, double *a, int *lda, int *ipiv, double *b, int *ldb, int *info);
void dtbcon_(char *norm, char *uplo, char *diag, int *n, int *kd, double *ab, int *ldab, double *rcond, double *work, int *iwork, int *info);
void dtbrfs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dtbtrs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, double *ab, int *ldab, double *b, int *ldb, int *info);
void dtgevc_(char *side, char *howmny, int *select, int *n, double *a, int *lda, double *b, int *ldb, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *info);
void dtgsja_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, int *k, int *l, double *a, int *lda, double *b, int *ldb, double *tola, double *tolb, double *alpha, double *beta, double *u, int *ldu, double *v, int *ldv, double *q, int *ldq, double *work, int *ncycle, int *info);
void dtpcon_(char *norm, char *uplo, char *diag, int *n, double *ap, double *rcond, double *work, int *iwork, int *info);
void dtprfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, double *ap, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dtptri_(char *uplo, char *diag, int *n, double *ap, int *info);
void dtptrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, double *ap, double *b, int *ldb, int *info);
void dtrcon_(char *norm, char *uplo, char *diag, int *n, double *a, int *lda, double *rcond, double *work, int *iwork, int *info);
void dtrevc_(char *side, char *howmny, int *select, int *n, double *t, int *ldt, double *vl, int *ldvl, double *vr, int *ldvr, int *mm, int *m, double *work, int *info);
void dtrexc_(char *compq, int *n, double *t, int *ldt, double *q, int *ldq, int *ifst, int *ilst, double *work, int *info);
void dtrrfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, double *x, int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info);
void dtrsen_(char *job, char *compq, int *select, int *n, double *t, int *ldt, double *q, int *ldq, double *wr, double *wi, int *m, double *s, double *sep, double *work, int *lwork, int *iwork, int *liwork, int *info);
void dtrsna_(char *job, char *howmny, int *select, int *n, double *t, int *ldt, double *vl, int *ldvl, double *vr, int *ldvr, double *s, double *sep, int *mm, int *m, double *work, int *ldwork, int *iwork, int *info);
void dtrsyl_(char *trana, char *tranb, int *isgn, int *m, int *n, double *a, int *lda, double *b, int *ldb, double *c, int *ldc, double *scale, int *info);
void dtrti2_(char *uplo, char *diag, int *n, double *a, int *lda, int *info);
void dtrtri_(char *uplo, char *diag, int *n, double *a, int *lda, int *info);
void dtrtrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, double *a, int *lda, double *b, int *ldb, int *info);
void dtzrqf_(int *m, int *n, double *a, int *lda, double *tau, int *info);
void zbdsqr_(char *uplo, int *n, int *ncvt, int *nru, int *ncc, double *d, double *e, cpx16 *vt, int *ldvt, cpx16 *u, int *ldu, cpx16 *c, int *ldc, double *rwork, int *info);
int zdrot_(int *n, void *cx, int *incx, void *cy, int *incy, double *c, double *s);
void zgbbrd_(char *vect, int *m, int *n, int *ncc, int *kl, int *ku, cpx16 *ab, int *ldab, double *d, double *e, cpx16 *q, int *ldq, cpx16 *pt, int *ldpt, cpx16 *c, int *ldc, cpx16 *work, double *rwork, int *info);
void zgbcon_(char *norm, int *n, int *kl, int *ku, cpx16 *ab, int *ldab, int *ipiv, double *anorm, double *rcond, cpx16 *work, double *rwork, int *info);
void zgbequ_(int *m, int *n, int *kl, int *ku, cpx16 *ab, int *ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);
void zgbrfs_(char *trans, int *n, int *kl, int *ku, int *nrhs, cpx16 *ab, int *ldab, cpx16 *afb, int *ldafb, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zgbsv_(int *n, int *kl, int *ku, int *nrhs, cpx16 *ab, int *ldab, int *ipiv, cpx16 *b, int *ldb, int *info);
void zgbsvx_(char *fact, char *trans, int *n, int *kl, int *ku, int *nrhs, cpx16 *ab, int *ldab, cpx16 *afb, int *ldafb, int *ipiv, char *equed, double *r, double *c, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zgbtf2_(int *m, int *n, int *kl, int *ku, cpx16 *ab, int *ldab, int *ipiv, int *info);
void zgbtrf_(int *m, int *n, int *kl, int *ku, cpx16 *ab, int *ldab, int *ipiv, int *info);
void zgbtrs_(char *trans, int *n, int *kl, int *ku, int *nrhs, cpx16 *ab, int *ldab, int *ipiv, cpx16 *b, int *ldb, int *info);
void zgebak_(char *job, char *side, int *n, int *ilo, int *ihi, double *scale, int *m, cpx16 *v, int *ldv, int *info);
void zgebal_(char *job, int *n, cpx16 *a, int *lda, int *ilo, int *ihi, double *scale, int *info);
void zgebd2_(int *m, int *n, cpx16 *a, int *lda, double *d, double *e, cpx16 *tauq, cpx16 *taup, cpx16 *work, int *info);
void zgebrd_(int *m, int *n, cpx16 *a, int *lda, double *d, double *e, cpx16 *tauq, cpx16 *taup, cpx16 *work, int *lwork, int *info);
void zgecon_(char *norm, int *n, cpx16 *a, int *lda, double *anorm, double *rcond, cpx16 *work, double *rwork, int *info);
void zgeequ_(int *m, int *n, cpx16 *a, int *lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax, int *info);
void zgees_(char *jobvs, char *sort, int *select, int *n, cpx16 *a, int *lda, int *sdim, cpx16 *w, cpx16 *vs, int *ldvs, cpx16 *work, int *lwork, double *rwork, int *bwork, int *info);
void zgeesx_(char *jobvs, char *sort, int *select, char *sense, int *n, cpx16 *a, int *lda, int *sdim, cpx16 *w, cpx16 *vs, int *ldvs, double *rconde, double *rcondv, cpx16 *work, int *lwork, double *rwork, int *bwork, int *info);
void zgeev_(char *jobvl, char *jobvr, int *n, cpx16 *a, int *lda, cpx16 *w, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, cpx16 *work, int *lwork, double *rwork, int *info);
void zgeevx_(char *balanc, char *jobvl, char *jobvr, char *sense, int *n, cpx16 *a, int *lda, cpx16 *w, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, cpx16 *work, int *lwork, double *rwork, int *info);
void zgegs_(char *jobvsl, char *jobvsr, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *alpha, cpx16 *beta, cpx16 *vsl, int *ldvsl, cpx16 *vsr, int *ldvsr, cpx16 *work, int *lwork, double *rwork, int *info);
void zgegv_(char *jobvl, char *jobvr, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *alpha, cpx16 *beta, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, cpx16 *work, int *lwork, double *rwork, int *info);
void zgehd2_(int *n, int *ilo, int *ihi, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zgehrd_(int *n, int *ilo, int *ihi, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zgelq2_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zgelqf_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zgels_(char *trans, int *m, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *work, int *lwork, int *info);
void zgelss_(int *m, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, double *s, double *rcond, int *rank, cpx16 *work, int *lwork, double *rwork, int *info);
void zgelsx_(int *m, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *jpvt, double *rcond, int *rank, cpx16 *work, double *rwork, int *info);
void zgeql2_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zgeqlf_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zgeqr2_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zgeqrf_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zgerfs_(char *trans, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zgerq2_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zgerqf_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zgesv_(int *n, int *nrhs, cpx16 *a, int *lda, int *ipiv, cpx16 *b, int *ldb, int *info);
void zgesvd_(char *jobu, char *jobvt, int *m, int *n, cpx16 *a, int *lda, double *s, cpx16 *u, int *ldu, cpx16 *vt, int *ldvt, cpx16 *work, int *lwork, double *rwork, int *info);
void zgesvx_(char *fact, char *trans, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, int *ipiv, char *equed, double *r, double *c, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zgetf2_(int *m, int *n, cpx16 *a, int *lda, int *ipiv, int *info);
void zgetrf_(int *m, int *n, cpx16 *a, int *lda, int *ipiv, int *info);
void zgetri_(int *n, cpx16 *a, int *lda, int *ipiv, cpx16 *work, int *lwork, int *info);
void zgetrs_(char *trans, int *n, int *nrhs, cpx16 *a, int *lda, int *ipiv, cpx16 *b, int *ldb, int *info);
void zggbak_(char *job, char *side, int *n, int *ilo, int *ihi, double *lscale, double *rscale, int *m, cpx16 *v, int *ldv, int *info);
void zggbal_(char *job, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info);
void zggglm_(int *n, int *m, int *p, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *d, cpx16 *x, cpx16 *y, cpx16 *work, int *lwork, int *info);
void zgghrd_(char *compq, char *compz, int *n, int *ilo, int *ihi, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *q, int *ldq, cpx16 *z, int *ldz, int *info);
void zgglse_(int *m, int *n, int *p, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *c, cpx16 *d, cpx16 *x, cpx16 *work, int *lwork, int *info);
void zggqrf_(int *n, int *m, int *p, cpx16 *a, int *lda, cpx16 *taua, cpx16 *b, int *ldb, cpx16 *taub, cpx16 *work, int *lwork, int *info);
void zggrqf_(int *m, int *p, int *n, cpx16 *a, int *lda, cpx16 *taua, cpx16 *b, int *ldb, cpx16 *taub, cpx16 *work, int *lwork, int *info);
void zggsvd_(char *jobu, char *jobv, char *jobq, int *m, int *n, int *p, int *k, int *l, cpx16 *a, int *lda, cpx16 *b, int *ldb, double *alpha, double *beta, cpx16 *u, int *ldu, cpx16 *v, int *ldv, cpx16 *q, int *ldq, cpx16 *work, double *rwork, int *iwork, int *info);
void zggsvp_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, double *tola, double *tolb, int *k, int *l, cpx16 *u, int *ldu, cpx16 *v, int *ldv, cpx16 *q, int *ldq, int *iwork, double *rwork, cpx16 *tau, cpx16 *work, int *info);
void zgtcon_(char *norm, int *n, cpx16 *dl, cpx16 *d, cpx16 *du, cpx16 *du2, int *ipiv, double *anorm, double *rcond, cpx16 *work, int *info);
void zgtrfs_(char *trans, int *n, int *nrhs, cpx16 *dl, cpx16 *d, cpx16 *du, cpx16 *dlf, cpx16 *df, cpx16 *duf, cpx16 *du2, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zgtsv_(int *n, int *nrhs, cpx16 *dl, cpx16 *d, cpx16 *du, cpx16 *b, int *ldb, int *info);
void zgtsvx_(char *fact, char *trans, int *n, int *nrhs, cpx16 *dl, cpx16 *d, cpx16 *du, cpx16 *dlf, cpx16 *df, cpx16 *duf, cpx16 *du2, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zgttrf_(int *n, cpx16 *dl, cpx16 *d, cpx16 *du, cpx16 *du2, int *ipiv, int *info);
void zgttrs_(char *trans, int *n, int *nrhs, cpx16 *dl, cpx16 *d, cpx16 *du, cpx16 *du2, int *ipiv, cpx16 *b, int *ldb, int *info);
void zhbev_(char *jobz, char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, double *w, cpx16 *z, int *ldz, cpx16 *work, double *rwork, int *info);
void zhbevd_(char *jobz, char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, double *w, cpx16 *z, int *ldz, cpx16 *work, int *lwork, double *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void zhbevx_(char *jobz, char *range, char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, cpx16 *q, int *ldq, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, cpx16 *z, int *ldz, cpx16 *work, double *rwork, int *iwork, int *ifail, int *info);
void zhbgst_(char *vect, char *uplo, int *n, int *ka, int *kb, cpx16 *ab, int *ldab, cpx16 *bb, int *ldbb, cpx16 *x, int *ldx, cpx16 *work, double *rwork, int *info);
void zhbgv_(char *jobz, char *uplo, int *n, int *ka, int *kb, cpx16 *ab, int *ldab, cpx16 *bb, int *ldbb, double *w, cpx16 *z, int *ldz, cpx16 *work, double *rwork, int *info);
void zhbtrd_(char *vect, char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, double *d, double *e, cpx16 *q, int *ldq, cpx16 *work, int *info);
void zhecon_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, double *anorm, double *rcond, cpx16 *work, int *info);
void zheev_(char *jobz, char *uplo, int *n, cpx16 *a, int *lda, double *w, cpx16 *work, int *lwork, double *rwork, int *info);
void zheevd_(char *jobz, char *uplo, int *n, cpx16 *a, int *lda, double *w, cpx16 *work, int *lwork, double *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void zheevx_(char *jobz, char *range, char *uplo, int *n, cpx16 *a, int *lda, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, cpx16 *z, int *ldz, cpx16 *work, int *lwork, double *rwork, int *iwork, int *ifail, int *info);
void zhegs2_(int *itype, char *uplo, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *info);
void zhegst_(int *itype, char *uplo, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *info);
void zhegv_(int *itype, char *jobz, char *uplo, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, double *w, cpx16 *work, int *lwork, double *rwork, int *info);
void zherfs_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zhesv_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, int *ipiv, cpx16 *b, int *ldb, cpx16 *work, int *lwork, int *info);
void zhesvx_(char *fact, char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, int *lwork, double *rwork, int *info);
void zhetd2_(char *uplo, int *n, cpx16 *a, int *lda, double *d, double *e, cpx16 *tau, int *info);
void zhetf2_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, int *info);
void zhetrd_(char *uplo, int *n, cpx16 *a, int *lda, double *d, double *e, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zhetrf_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, cpx16 *work, int *lwork, int *info);
void zhetri_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, cpx16 *work, int *info);
void zhetrs_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, int *ipiv, cpx16 *b, int *ldb, int *info);
void zhgeqz_(char *job, char *compq, char *compz, int *n, int *ilo, int *ihi, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *alpha, cpx16 *beta, cpx16 *q, int *ldq, cpx16 *z, int *ldz, cpx16 *work, int *lwork, double *rwork, int *info);
void zhpcon_(char *uplo, int *n, cpx16 *ap, int *ipiv, double *anorm, double *rcond, cpx16 *work, int *info);
void zhpev_(char *jobz, char *uplo, int *n, cpx16 *ap, double *w, cpx16 *z, int *ldz, cpx16 *work, double *rwork, int *info);
void zhpevd_(char *jobz, char *uplo, int *n, cpx16 *ap, double *w, cpx16 *z, int *ldz, cpx16 *work, int *lwork, double *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void zhpevx_(char *jobz, char *range, char *uplo, int *n, cpx16 *ap, double *vl, double *vu, int *il, int *iu, double *abstol, int *m, double *w, cpx16 *z, int *ldz, cpx16 *work, double *rwork, int *iwork, int *ifail, int *info);
void zhpgst_(int *itype, char *uplo, int *n, cpx16 *ap, cpx16 *bp, int *info);
void zhpgv_(int *itype, char *jobz, char *uplo, int *n, cpx16 *ap, cpx16 *bp, double *w, cpx16 *z, int *ldz, cpx16 *work, double *rwork, int *info);
void zhprfs_(char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *afp, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zhpsv_(char *uplo, int *n, int *nrhs, cpx16 *ap, int *ipiv, cpx16 *b, int *ldb, int *info);
void zhpsvx_(char *fact, char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *afp, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zhptrd_(char *uplo, int *n, cpx16 *ap, double *d, double *e, cpx16 *tau, int *info);
void zhptrf_(char *uplo, int *n, cpx16 *ap, int *ipiv, int *info);
void zhptri_(char *uplo, int *n, cpx16 *ap, int *ipiv, cpx16 *work, int *info);
void zhptrs_(char *uplo, int *n, int *nrhs, cpx16 *ap, int *ipiv, cpx16 *b, int *ldb, int *info);
void zhsein_(char *side, char *eigsrc, char *initv, int *select, int *n, cpx16 *h, int *ldh, cpx16 *w, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, int *mm, int *m, cpx16 *work, double *rwork, int *ifaill, int *ifailr, int *info);
void zhseqr_(char *job, char *compz, int *n, int *ilo, int *ihi, cpx16 *h, int *ldh, cpx16 *w, cpx16 *z, int *ldz, cpx16 *work, int *lwork, int *info);
void zlaed0_(int *qsiz, int *n, double *d, double *e, cpx16 *q, int *ldq, cpx16 *qstore, int *ldqs, double *rwork, int *iwork, int *info);
void zlaed7_(int *n, int *cutpnt, int *qsiz, int *tlvls, int *curlvl, int *curpbm, double *d, cpx16 *q, int *ldq, double *rho, int *indxq, double *qstore, int *qptr, int *prmptr, int *perm, int *givptr, int *givcol, double *givnum, cpx16 *work, double *rwork, int *iwork, int *info);
void zlaed8_(int *k, int *n, int *qsiz, cpx16 *q, int *ldq, double *d, double *rho, int *cutpnt, double *z, double *dlamda, cpx16 *q2, int *ldq2, double *w, int *indxp, int *indx, int *indxq, int *perm, int *givptr, int *givcol, double *givnum, int *info);
void zlatzm_(char *side, int *m, int *n, cpx16 *v, int *incv, cpx16 *tau, cpx16 *c1, cpx16 *c2, int *ldc, cpx16 *work);
void zpbcon_(char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, double *anorm, double *rcond, cpx16 *work, double *rwork, int *info);
void zpbequ_(char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, double *s, double *scond, double *amax, int *info);
void zpbrfs_(char *uplo, int *n, int *kd, int *nrhs, cpx16 *ab, int *ldab, cpx16 *afb, int *ldafb, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zpbstf_(char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, int *info);
void zpbsv_(char *uplo, int *n, int *kd, int *nrhs, cpx16 *ab, int *ldab, cpx16 *b, int *ldb, int *info);
void zpbsvx_(char *fact, char *uplo, int *n, int *kd, int *nrhs, cpx16 *ab, int *ldab, cpx16 *afb, int *ldafb, char *equed, double *s, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zpbtf2_(char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, int *info);
void zpbtrf_(char *uplo, int *n, int *kd, cpx16 *ab, int *ldab, int *info);
void zpbtrs_(char *uplo, int *n, int *kd, int *nrhs, cpx16 *ab, int *ldab, cpx16 *b, int *ldb, int *info);
void zpocon_(char *uplo, int *n, cpx16 *a, int *lda, double *anorm, double *rcond, cpx16 *work, double *rwork, int *info);
void zpoequ_(int *n, cpx16 *a, int *lda, double *s, double *scond, double *amax, int *info);
void zporfs_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zposv_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *info);
void zposvx_(char *fact, char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, char *equed, double *s, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zpotf2_(char *uplo, int *n, cpx16 *a, int *lda, int *info);
void zpotrf_(char *uplo, int *n, cpx16 *a, int *lda, int *info);
void zpotri_(char *uplo, int *n, cpx16 *a, int *lda, int *info);
void zpotrs_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *info);
void zppcon_(char *uplo, int *n, cpx16 *ap, double *anorm, double *rcond, cpx16 *work, double *rwork, int *info);
void zppequ_(char *uplo, int *n, cpx16 *ap, double *s, double *scond, double *amax, int *info);
void zpprfs_(char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *afp, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zppsv_(char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *b, int *ldb, int *info);
void zppsvx_(char *fact, char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *afp, char *equed, double *s, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zpptrf_(char *uplo, int *n, cpx16 *ap, int *info);
void zpptri_(char *uplo, int *n, cpx16 *ap, int *info);
void zpptrs_(char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *b, int *ldb, int *info);
void zptcon_(int *n, double *d, cpx16 *e, double *anorm, double *rcond, double *rwork, int *info);
void zpteqr_(char *compz, int *n, double *d, double *e, cpx16 *z, int *ldz, double *work, int *info);
void zptrfs_(char *uplo, int *n, int *nrhs, double *d, cpx16 *e, double *df, cpx16 *ef, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zptsv_(int *n, int *nrhs, double *d, cpx16 *e, cpx16 *b, int *ldb, int *info);
void zptsvx_(char *fact, int *n, int *nrhs, double *d, cpx16 *e, double *df, cpx16 *ef, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zpttrf_(int *n, double *d, cpx16 *e, int *info);
void zpttrs_(char *uplo, int *n, int *nrhs, double *d, cpx16 *e, cpx16 *b, int *ldb, int *info);
void zspcon_(char *uplo, int *n, cpx16 *ap, int *ipiv, double *anorm, double *rcond, cpx16 *work, int *info);
void zsprfs_(char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *afp, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zspsv_(char *uplo, int *n, int *nrhs, cpx16 *ap, int *ipiv, cpx16 *b, int *ldb, int *info);
void zspsvx_(char *fact, char *uplo, int *n, int *nrhs, cpx16 *ap, cpx16 *afp, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zsptrf_(char *uplo, int *n, cpx16 *ap, int *ipiv, int *info);
void zsptri_(char *uplo, int *n, cpx16 *ap, int *ipiv, cpx16 *work, int *info);
void zsptrs_(char *uplo, int *n, int *nrhs, cpx16 *ap, int *ipiv, cpx16 *b, int *ldb, int *info);
void zstedc_(char *compz, int *n, double *d, double *e, cpx16 *z, int *ldz, cpx16 *work, int *lwork, double *rwork, int *lrwork, int *iwork, int *liwork, int *info);
void zstein_(int *n, double *d, double *e, int *m, double *w, int *iblock, int *isplit, cpx16 *z, int *ldz, double *work, int *iwork, int *ifail, int *info);
void zsteqr_(char *compz, int *n, double *d, double *e, cpx16 *z, int *ldz, double *work, int *info);
void zsycon_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, double *anorm, double *rcond, cpx16 *work, int *info);
void zsyrfs_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void zsysv_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, int *ipiv, cpx16 *b, int *ldb, cpx16 *work, int *lwork, int *info);
void zsysvx_(char *fact, char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *af, int *ldaf, int *ipiv, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *rcond, double *ferr, double *berr, cpx16 *work, int *lwork, double *rwork, int *info);
void zsytf2_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, int *info);
void zsytrf_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, cpx16 *work, int *lwork, int *info);
void zsytri_(char *uplo, int *n, cpx16 *a, int *lda, int *ipiv, cpx16 *work, int *info);
void zsytrs_(char *uplo, int *n, int *nrhs, cpx16 *a, int *lda, int *ipiv, cpx16 *b, int *ldb, int *info);
void ztbcon_(char *norm, char *uplo, char *diag, int *n, int *kd, cpx16 *ab, int *ldab, double *rcond, cpx16 *work, double *rwork, int *info);
void ztbrfs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, cpx16 *ab, int *ldab, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void ztbtrs_(char *uplo, char *trans, char *diag, int *n, int *kd, int *nrhs, cpx16 *ab, int *ldab, cpx16 *b, int *ldb, int *info);
void ztgevc_(char *side, char *howmny, int *select, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, int *mm, int *m, cpx16 *work, double *rwork, int *info);
void ztgsja_(char *jobu, char *jobv, char *jobq, int *m, int *p, int *n, int *k, int *l, cpx16 *a, int *lda, cpx16 *b, int *ldb, double *tola, double *tolb, double *alpha, double *beta, cpx16 *u, int *ldu, cpx16 *v, int *ldv, cpx16 *q, int *ldq, cpx16 *work, int *ncycle, int *info);
void ztpcon_(char *norm, char *uplo, char *diag, int *n, cpx16 *ap, double *rcond, cpx16 *work, double *rwork, int *info);
void ztprfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx16 *ap, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void ztptri_(char *uplo, char *diag, int *n, cpx16 *ap, int *info);
void ztptrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx16 *ap, cpx16 *b, int *ldb, int *info);
void ztrcon_(char *norm, char *uplo, char *diag, int *n, cpx16 *a, int *lda, double *rcond, cpx16 *work, double *rwork, int *info);
void ztrevc_(char *side, char *howmny, int *select, int *n, cpx16 *t, int *ldt, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, int *mm, int *m, cpx16 *work, double *rwork, int *info);
void ztrexc_(char *compq, int *n, cpx16 *t, int *ldt, cpx16 *q, int *ldq, int *ifst, int *ilst, int *info);
void ztrrfs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *x, int *ldx, double *ferr, double *berr, cpx16 *work, double *rwork, int *info);
void ztrsen_(char *job, char *compq, int *select, int *n, cpx16 *t, int *ldt, cpx16 *q, int *ldq, cpx16 *w, int *m, double *s, double *sep, cpx16 *work, int *lwork, int *info);
void ztrsna_(char *job, char *howmny, int *select, int *n, cpx16 *t, int *ldt, cpx16 *vl, int *ldvl, cpx16 *vr, int *ldvr, double *s, double *sep, int *mm, int *m, cpx16 *work, int *ldwork, double *rwork, int *info);
void ztrsyl_(char *trana, char *tranb, int *isgn, int *m, int *n, cpx16 *a, int *lda, cpx16 *b, int *ldb, cpx16 *c, int *ldc, double *scale, int *info);
void ztrti2_(char *uplo, char *diag, int *n, cpx16 *a, int *lda, int *info);
void ztrtri_(char *uplo, char *diag, int *n, cpx16 *a, int *lda, int *info);
void ztrtrs_(char *uplo, char *trans, char *diag, int *n, int *nrhs, cpx16 *a, int *lda, cpx16 *b, int *ldb, int *info);
void ztzrqf_(int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, int *info);
void zung2l_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zung2r_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zungbr_(char *vect, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zunghr_(int *n, int *ilo, int *ihi, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zungl2_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zunglq_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zungql_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zungqr_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zungr2_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *info);
void zungrq_(int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zungtr_(char *uplo, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *work, int *lwork, int *info);
void zunm2l_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *info);
void zunm2r_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *info);
void zunmbr_(char *vect, char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zunmhr_(char *side, char *trans, int *m, int *n, int *ilo, int *ihi, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zunml2_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *info);
void zunmlq_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zunmql_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zunmqr_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zunmr2_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *info);
void zunmrq_(char *side, char *trans, int *m, int *n, int *k, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zunmtr_(char *side, char *uplo, char *trans, int *m, int *n, cpx16 *a, int *lda, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *lwork, int *info);
void zupgtr_(char *uplo, int *n, cpx16 *ap, cpx16 *tau, cpx16 *q, int *ldq, cpx16 *work, int *info);
void zupmtr_(char *side, char *uplo, char *trans, int *m, int *n, cpx16 *ap, cpx16 *tau, cpx16 *c, int *ldc, cpx16 *work, int *info);

void cgeqp3_(int *m, int *n, cpx8 *a, int *lda, int *jpvt, cpx8 *tau, cpx8 *work, int *lwork, float* rwork, int *info);
void zgeqp3_(int *m, int *n, cpx16 *a, int *lda, int *jpvt, cpx16 *tau, cpx16 *work, int *lwork, double* rwork, int *info);

#endif

#endif

#endif
